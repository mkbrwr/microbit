// Generated by svd2swift.

import MMIO

/// Accelerated Address Resolver
@RegisterBlock
struct AAR {
    /// Start resolving addresses based on IRKs specified in the IRK data structure
    @RegisterBlock(offset: 0x0)
    var tasks_start: Register<TASKS_START>

    /// Stop resolving addresses
    @RegisterBlock(offset: 0x8)
    var tasks_stop: Register<TASKS_STOP>

    /// Address resolution procedure complete
    @RegisterBlock(offset: 0x100)
    var events_end: Register<EVENTS_END>

    /// Address resolved
    @RegisterBlock(offset: 0x104)
    var events_resolved: Register<EVENTS_RESOLVED>

    /// Address not resolved
    @RegisterBlock(offset: 0x108)
    var events_notresolved: Register<EVENTS_NOTRESOLVED>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// Resolution status
    @RegisterBlock(offset: 0x400)
    var status: Register<STATUS>

    /// Enable AAR
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// Number of IRKs
    @RegisterBlock(offset: 0x504)
    var nirk: Register<NIRK>

    /// Pointer to IRK data structure
    @RegisterBlock(offset: 0x508)
    var irkptr: Register<IRKPTR>

    /// Pointer to the resolvable address
    @RegisterBlock(offset: 0x510)
    var addrptr: Register<ADDRPTR>

    /// Pointer to data area used for temporary storage
    @RegisterBlock(offset: 0x514)
    var scratchptr: Register<SCRATCHPTR>
}

extension AAR {
    /// Start resolving addresses based on IRKs specified in the IRK data structure
    @Register(bitWidth: 32)
    struct TASKS_START {
        /// Start resolving addresses based on IRKs specified in the IRK data structure
        @WriteOnly(bits: 0..<1, as: TASKS_START_FIELDValues.self)
        var tasks_start_field: TASKS_START_FIELD
    }

    /// Stop resolving addresses
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stop resolving addresses
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// Address resolution procedure complete
    @Register(bitWidth: 32)
    struct EVENTS_END {
        /// Address resolution procedure complete
        @ReadWrite(bits: 0..<1, as: EVENTS_END_FIELDValues.self)
        var events_end_field: EVENTS_END_FIELD
    }

    /// Address resolved
    @Register(bitWidth: 32)
    struct EVENTS_RESOLVED {
        /// Address resolved
        @ReadWrite(bits: 0..<1, as: EVENTS_RESOLVED_FIELDValues.self)
        var events_resolved_field: EVENTS_RESOLVED_FIELD
    }

    /// Address not resolved
    @Register(bitWidth: 32)
    struct EVENTS_NOTRESOLVED {
        /// Address not resolved
        @ReadWrite(bits: 0..<1, as: EVENTS_NOTRESOLVED_FIELDValues.self)
        var events_notresolved_field: EVENTS_NOTRESOLVED_FIELD
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event END
        @ReadWrite(bits: 0..<1)
        var end: END

        /// Write '1' to enable interrupt for event RESOLVED
        @ReadWrite(bits: 1..<2)
        var resolved: RESOLVED

        /// Write '1' to enable interrupt for event NOTRESOLVED
        @ReadWrite(bits: 2..<3)
        var notresolved: NOTRESOLVED
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event END
        @ReadWrite(bits: 0..<1)
        var end: END

        /// Write '1' to disable interrupt for event RESOLVED
        @ReadWrite(bits: 1..<2)
        var resolved: RESOLVED

        /// Write '1' to disable interrupt for event NOTRESOLVED
        @ReadWrite(bits: 2..<3)
        var notresolved: NOTRESOLVED
    }

    /// Resolution status
    @Register(bitWidth: 32)
    struct STATUS {
        /// The IRK that was used last time an address was resolved
        @ReadOnly(bits: 0..<4)
        var status_field: STATUS_FIELD
    }

    /// Enable AAR
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable or disable AAR
        @ReadWrite(bits: 0..<2, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// Number of IRKs
    @Register(bitWidth: 32)
    struct NIRK {
        /// Number of Identity Root Keys available in the IRK data structure
        @ReadWrite(bits: 0..<5)
        var nirk_field: NIRK_FIELD
    }

    /// Pointer to IRK data structure
    @Register(bitWidth: 32)
    struct IRKPTR {
        /// Pointer to the IRK data structure
        @ReadWrite(bits: 0..<32)
        var irkptr_field: IRKPTR_FIELD
    }

    /// Pointer to the resolvable address
    @Register(bitWidth: 32)
    struct ADDRPTR {
        /// Pointer to the resolvable address (6-bytes)
        @ReadWrite(bits: 0..<32)
        var addrptr_field: ADDRPTR_FIELD
    }

    /// Pointer to data area used for temporary storage
    @Register(bitWidth: 32)
    struct SCRATCHPTR {
        /// Pointer to a scratch data area used for temporary storage during resolution. A space of minimum 3 bytes must be reserved.
        @ReadWrite(bits: 0..<32)
        var scratchptr_field: SCRATCHPTR_FIELD
    }
}

extension AAR.TASKS_START {
    struct TASKS_START_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension AAR.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension AAR.EVENTS_END {
    struct EVENTS_END_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension AAR.EVENTS_RESOLVED {
    struct EVENTS_RESOLVED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension AAR.EVENTS_NOTRESOLVED {
    struct EVENTS_NOTRESOLVED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension AAR.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
