// Generated by svd2swift.

import MMIO

/// SPI Slave 0
@RegisterBlock
struct SPIS0 {
    /// Acquire SPI semaphore
    @RegisterBlock(offset: 0x24)
    var tasks_acquire: Register<TASKS_ACQUIRE>

    /// Release SPI semaphore, enabling the SPI slave to acquire it
    @RegisterBlock(offset: 0x28)
    var tasks_release: Register<TASKS_RELEASE>

    /// Granted transaction completed
    @RegisterBlock(offset: 0x104)
    var events_end: Register<EVENTS_END>

    /// End of RXD buffer reached
    @RegisterBlock(offset: 0x110)
    var events_endrx: Register<EVENTS_ENDRX>

    /// Semaphore acquired
    @RegisterBlock(offset: 0x128)
    var events_acquired: Register<EVENTS_ACQUIRED>

    /// Shortcuts between local events and tasks
    @RegisterBlock(offset: 0x200)
    var shorts: Register<SHORTS>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// Semaphore status register
    @RegisterBlock(offset: 0x400)
    var semstat: Register<SEMSTAT>

    /// Status from last transaction
    @RegisterBlock(offset: 0x440)
    var status: Register<STATUS>

    /// Enable SPI slave
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// Configuration register
    @RegisterBlock(offset: 0x554)
    var config: Register<CONFIG>

    /// Default character. Character clocked out in case of an ignored transaction.
    @RegisterBlock(offset: 0x55c)
    var def: Register<DEF>

    /// Over-read character
    @RegisterBlock(offset: 0x5c0)
    var orc: Register<ORC>

    /// Unspecified
    @RegisterBlock(offset: 0x508)
    var psel: PSEL

    /// Unspecified
    @RegisterBlock(offset: 0x534)
    var rxd: RXD

    /// Unspecified
    @RegisterBlock(offset: 0x544)
    var txd: TXD
}

extension SPIS0 {
    /// Acquire SPI semaphore
    @Register(bitWidth: 32)
    struct TASKS_ACQUIRE {
        /// Acquire SPI semaphore
        @WriteOnly(bits: 0..<1, as: TASKS_ACQUIRE_FIELDValues.self)
        var tasks_acquire_field: TASKS_ACQUIRE_FIELD
    }

    /// Release SPI semaphore, enabling the SPI slave to acquire it
    @Register(bitWidth: 32)
    struct TASKS_RELEASE {
        /// Release SPI semaphore, enabling the SPI slave to acquire it
        @WriteOnly(bits: 0..<1, as: TASKS_RELEASE_FIELDValues.self)
        var tasks_release_field: TASKS_RELEASE_FIELD
    }

    /// Granted transaction completed
    @Register(bitWidth: 32)
    struct EVENTS_END {
        /// Granted transaction completed
        @ReadWrite(bits: 0..<1, as: EVENTS_END_FIELDValues.self)
        var events_end_field: EVENTS_END_FIELD
    }

    /// End of RXD buffer reached
    @Register(bitWidth: 32)
    struct EVENTS_ENDRX {
        /// End of RXD buffer reached
        @ReadWrite(bits: 0..<1, as: EVENTS_ENDRX_FIELDValues.self)
        var events_endrx_field: EVENTS_ENDRX_FIELD
    }

    /// Semaphore acquired
    @Register(bitWidth: 32)
    struct EVENTS_ACQUIRED {
        /// Semaphore acquired
        @ReadWrite(bits: 0..<1, as: EVENTS_ACQUIRED_FIELDValues.self)
        var events_acquired_field: EVENTS_ACQUIRED_FIELD
    }

    /// Shortcuts between local events and tasks
    @Register(bitWidth: 32)
    struct SHORTS {
        /// Shortcut between event END and task ACQUIRE
        @ReadWrite(bits: 2..<3, as: END_ACQUIREValues.self)
        var end_acquire: END_ACQUIRE
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event END
        @ReadWrite(bits: 1..<2)
        var end: END

        /// Write '1' to enable interrupt for event ENDRX
        @ReadWrite(bits: 4..<5)
        var endrx: ENDRX

        /// Write '1' to enable interrupt for event ACQUIRED
        @ReadWrite(bits: 10..<11)
        var acquired: ACQUIRED
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event END
        @ReadWrite(bits: 1..<2)
        var end: END

        /// Write '1' to disable interrupt for event ENDRX
        @ReadWrite(bits: 4..<5)
        var endrx: ENDRX

        /// Write '1' to disable interrupt for event ACQUIRED
        @ReadWrite(bits: 10..<11)
        var acquired: ACQUIRED
    }

    /// Semaphore status register
    @Register(bitWidth: 32)
    struct SEMSTAT {
        /// Semaphore status
        @ReadOnly(bits: 0..<2, as: SEMSTAT_FIELDValues.self)
        var semstat_field: SEMSTAT_FIELD
    }

    /// Status from last transaction
    @Register(bitWidth: 32)
    struct STATUS {
        /// TX buffer over-read detected, and prevented
        @ReadWrite(bits: 0..<1)
        var overread: OVERREAD

        /// RX buffer overflow detected, and prevented
        @ReadWrite(bits: 1..<2)
        var overflow: OVERFLOW
    }

    /// Enable SPI slave
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable or disable SPI slave
        @ReadWrite(bits: 0..<4, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// Configuration register
    @Register(bitWidth: 32)
    struct CONFIG {
        /// Bit order
        @ReadWrite(bits: 0..<1, as: ORDERValues.self)
        var order: ORDER

        /// Serial clock (SCK) phase
        @ReadWrite(bits: 1..<2, as: CPHAValues.self)
        var cpha: CPHA

        /// Serial clock (SCK) polarity
        @ReadWrite(bits: 2..<3, as: CPOLValues.self)
        var cpol: CPOL
    }

    /// Default character. Character clocked out in case of an ignored transaction.
    @Register(bitWidth: 32)
    struct DEF {
        /// Default character. Character clocked out in case of an ignored transaction.
        @ReadWrite(bits: 0..<8)
        var def_field: DEF_FIELD
    }

    /// Over-read character
    @Register(bitWidth: 32)
    struct ORC {
        /// Over-read character. Character clocked out after an over-read of the transmit buffer.
        @ReadWrite(bits: 0..<8)
        var orc_field: ORC_FIELD
    }

    /// Unspecified
    @RegisterBlock
    struct PSEL {
        /// Pin select for SCK
        @RegisterBlock(offset: 0x0)
        var sck: Register<SCK>

        /// Pin select for MISO signal
        @RegisterBlock(offset: 0x4)
        var miso: Register<MISO>

        /// Pin select for MOSI signal
        @RegisterBlock(offset: 0x8)
        var mosi: Register<MOSI>

        /// Pin select for CSN signal
        @RegisterBlock(offset: 0xc)
        var csn: Register<CSN>
    }

    /// Unspecified
    @RegisterBlock
    struct RXD {
        /// RXD data pointer
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>

        /// Maximum number of bytes in receive buffer
        @RegisterBlock(offset: 0x4)
        var maxcnt: Register<MAXCNT>

        /// Number of bytes received in last granted transaction
        @RegisterBlock(offset: 0x8)
        var amount: Register<AMOUNT>

        /// EasyDMA list type
        @RegisterBlock(offset: 0xc)
        var list: Register<LIST>
    }

    /// Unspecified
    @RegisterBlock
    struct TXD {
        /// TXD data pointer
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>

        /// Maximum number of bytes in transmit buffer
        @RegisterBlock(offset: 0x4)
        var maxcnt: Register<MAXCNT>

        /// Number of bytes transmitted in last granted transaction
        @RegisterBlock(offset: 0x8)
        var amount: Register<AMOUNT>

        /// EasyDMA list type
        @RegisterBlock(offset: 0xc)
        var list: Register<LIST>
    }
}

extension SPIS0.PSEL {
    /// Pin select for SCK
    @Register(bitWidth: 32)
    struct SCK {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for MISO signal
    @Register(bitWidth: 32)
    struct MISO {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for MOSI signal
    @Register(bitWidth: 32)
    struct MOSI {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for CSN signal
    @Register(bitWidth: 32)
    struct CSN {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }
}

extension SPIS0.RXD {
    /// RXD data pointer
    @Register(bitWidth: 32)
    struct PTR {
        /// RXD data pointer
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }

    /// Maximum number of bytes in receive buffer
    @Register(bitWidth: 32)
    struct MAXCNT {
        /// Maximum number of bytes in receive buffer
        @ReadWrite(bits: 0..<16)
        var maxcnt_field: MAXCNT_FIELD
    }

    /// Number of bytes received in last granted transaction
    @Register(bitWidth: 32)
    struct AMOUNT {
        /// Number of bytes received in the last granted transaction
        @ReadOnly(bits: 0..<16)
        var amount_field: AMOUNT_FIELD
    }

    /// EasyDMA list type
    @Register(bitWidth: 32)
    struct LIST {
        /// List type
        @ReadWrite(bits: 0..<2, as: LIST_FIELDValues.self)
        var list_field: LIST_FIELD
    }
}

extension SPIS0.TXD {
    /// TXD data pointer
    @Register(bitWidth: 32)
    struct PTR {
        /// TXD data pointer
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }

    /// Maximum number of bytes in transmit buffer
    @Register(bitWidth: 32)
    struct MAXCNT {
        /// Maximum number of bytes in transmit buffer
        @ReadWrite(bits: 0..<16)
        var maxcnt_field: MAXCNT_FIELD
    }

    /// Number of bytes transmitted in last granted transaction
    @Register(bitWidth: 32)
    struct AMOUNT {
        /// Number of bytes transmitted in last granted transaction
        @ReadOnly(bits: 0..<16)
        var amount_field: AMOUNT_FIELD
    }

    /// EasyDMA list type
    @Register(bitWidth: 32)
    struct LIST {
        /// List type
        @ReadWrite(bits: 0..<2, as: LIST_FIELDValues.self)
        var list_field: LIST_FIELD
    }
}

extension SPIS0.TASKS_ACQUIRE {
    struct TASKS_ACQUIRE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.TASKS_RELEASE {
    struct TASKS_RELEASE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.EVENTS_END {
    struct EVENTS_END_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.EVENTS_ENDRX {
    struct EVENTS_ENDRX_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.EVENTS_ACQUIRED {
    struct EVENTS_ACQUIRED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.SHORTS {
    struct END_ACQUIREValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.SEMSTAT {
    struct SEMSTAT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Semaphore is free
        static let Free = Self(rawValue: 0x0)

        /// Semaphore is assigned to CPU
        static let CPU = Self(rawValue: 0x1)

        /// Semaphore is assigned to SPI slave
        static let SPIS = Self(rawValue: 0x2)

        /// Semaphore is assigned to SPI but a handover to the CPU is pending
        static let CPUPending = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// Disable SPI slave
        static let Disabled = Self(rawValue: 0x0)

        /// Enable SPI slave
        static let Enabled = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.CONFIG {
    struct ORDERValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Most significant bit shifted out first
        static let MsbFirst = Self(rawValue: 0x0)

        /// Least significant bit shifted out first
        static let LsbFirst = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.CONFIG {
    struct CPHAValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Sample on leading edge of clock, shift serial data on trailing edge
        static let Leading = Self(rawValue: 0x0)

        /// Sample on trailing edge of clock, shift serial data on leading edge
        static let Trailing = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.CONFIG {
    struct CPOLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Active high
        static let ActiveHigh = Self(rawValue: 0x0)

        /// Active low
        static let ActiveLow = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.PSEL.SCK {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.PSEL.MISO {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.PSEL.MOSI {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.PSEL.CSN {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.RXD.LIST {
    struct LIST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Disable EasyDMA list
        static let Disabled = Self(rawValue: 0x0)

        /// Use array list
        static let ArrayList = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIS0.TXD.LIST {
    struct LIST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Disable EasyDMA list
        static let Disabled = Self(rawValue: 0x0)

        /// Use array list
        static let ArrayList = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
