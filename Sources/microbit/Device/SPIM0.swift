// Generated by svd2swift.

import MMIO

/// Serial Peripheral Interface Master with EasyDMA 0
@RegisterBlock
struct SPIM0 {
    /// Start SPI transaction
    @RegisterBlock(offset: 0x10)
    var tasks_start: Register<TASKS_START>

    /// Stop SPI transaction
    @RegisterBlock(offset: 0x14)
    var tasks_stop: Register<TASKS_STOP>

    /// Suspend SPI transaction
    @RegisterBlock(offset: 0x1c)
    var tasks_suspend: Register<TASKS_SUSPEND>

    /// Resume SPI transaction
    @RegisterBlock(offset: 0x20)
    var tasks_resume: Register<TASKS_RESUME>

    /// SPI transaction has stopped
    @RegisterBlock(offset: 0x104)
    var events_stopped: Register<EVENTS_STOPPED>

    /// End of RXD buffer reached
    @RegisterBlock(offset: 0x110)
    var events_endrx: Register<EVENTS_ENDRX>

    /// End of RXD buffer and TXD buffer reached
    @RegisterBlock(offset: 0x118)
    var events_end: Register<EVENTS_END>

    /// End of TXD buffer reached
    @RegisterBlock(offset: 0x120)
    var events_endtx: Register<EVENTS_ENDTX>

    /// Transaction started
    @RegisterBlock(offset: 0x14c)
    var events_started: Register<EVENTS_STARTED>

    /// Shortcuts between local events and tasks
    @RegisterBlock(offset: 0x200)
    var shorts: Register<SHORTS>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// Stall status for EasyDMA RAM accesses. The fields in this register are set to STALL by hardware whenever a stall occurs and can be cleared (set to NOSTALL) by the CPU.
    @RegisterBlock(offset: 0x400)
    var stallstat: Register<STALLSTAT>

    /// Enable SPIM
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// SPI frequency. Accuracy depends on the HFCLK source selected.
    @RegisterBlock(offset: 0x524)
    var frequency: Register<FREQUENCY>

    /// Configuration register
    @RegisterBlock(offset: 0x554)
    var config: Register<CONFIG>

    /// Polarity of CSN output
    @RegisterBlock(offset: 0x568)
    var csnpol: Register<CSNPOL>

    /// Pin select for DCX signal
    @RegisterBlock(offset: 0x56c)
    var pseldcx: Register<PSELDCX>

    /// DCX configuration
    @RegisterBlock(offset: 0x570)
    var dcxcnt: Register<DCXCNT>

    /// Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
    @RegisterBlock(offset: 0x5c0)
    var orc: Register<ORC>

    /// Unspecified
    @RegisterBlock(offset: 0x508)
    var psel: PSEL

    /// RXD EasyDMA channel
    @RegisterBlock(offset: 0x534)
    var rxd: RXD

    /// TXD EasyDMA channel
    @RegisterBlock(offset: 0x544)
    var txd: TXD

    /// Unspecified
    @RegisterBlock(offset: 0x560)
    var iftiming: IFTIMING
}

extension SPIM0 {
    /// Start SPI transaction
    @Register(bitWidth: 32)
    struct TASKS_START {
        /// Start SPI transaction
        @WriteOnly(bits: 0..<1, as: TASKS_START_FIELDValues.self)
        var tasks_start_field: TASKS_START_FIELD
    }

    /// Stop SPI transaction
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stop SPI transaction
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// Suspend SPI transaction
    @Register(bitWidth: 32)
    struct TASKS_SUSPEND {
        /// Suspend SPI transaction
        @WriteOnly(bits: 0..<1, as: TASKS_SUSPEND_FIELDValues.self)
        var tasks_suspend_field: TASKS_SUSPEND_FIELD
    }

    /// Resume SPI transaction
    @Register(bitWidth: 32)
    struct TASKS_RESUME {
        /// Resume SPI transaction
        @WriteOnly(bits: 0..<1, as: TASKS_RESUME_FIELDValues.self)
        var tasks_resume_field: TASKS_RESUME_FIELD
    }

    /// SPI transaction has stopped
    @Register(bitWidth: 32)
    struct EVENTS_STOPPED {
        /// SPI transaction has stopped
        @ReadWrite(bits: 0..<1, as: EVENTS_STOPPED_FIELDValues.self)
        var events_stopped_field: EVENTS_STOPPED_FIELD
    }

    /// End of RXD buffer reached
    @Register(bitWidth: 32)
    struct EVENTS_ENDRX {
        /// End of RXD buffer reached
        @ReadWrite(bits: 0..<1, as: EVENTS_ENDRX_FIELDValues.self)
        var events_endrx_field: EVENTS_ENDRX_FIELD
    }

    /// End of RXD buffer and TXD buffer reached
    @Register(bitWidth: 32)
    struct EVENTS_END {
        /// End of RXD buffer and TXD buffer reached
        @ReadWrite(bits: 0..<1, as: EVENTS_END_FIELDValues.self)
        var events_end_field: EVENTS_END_FIELD
    }

    /// End of TXD buffer reached
    @Register(bitWidth: 32)
    struct EVENTS_ENDTX {
        /// End of TXD buffer reached
        @ReadWrite(bits: 0..<1, as: EVENTS_ENDTX_FIELDValues.self)
        var events_endtx_field: EVENTS_ENDTX_FIELD
    }

    /// Transaction started
    @Register(bitWidth: 32)
    struct EVENTS_STARTED {
        /// Transaction started
        @ReadWrite(bits: 0..<1, as: EVENTS_STARTED_FIELDValues.self)
        var events_started_field: EVENTS_STARTED_FIELD
    }

    /// Shortcuts between local events and tasks
    @Register(bitWidth: 32)
    struct SHORTS {
        /// Shortcut between event END and task START
        @ReadWrite(bits: 17..<18, as: END_STARTValues.self)
        var end_start: END_START
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event STOPPED
        @ReadWrite(bits: 1..<2)
        var stopped: STOPPED

        /// Write '1' to enable interrupt for event ENDRX
        @ReadWrite(bits: 4..<5)
        var endrx: ENDRX

        /// Write '1' to enable interrupt for event END
        @ReadWrite(bits: 6..<7)
        var end: END

        /// Write '1' to enable interrupt for event ENDTX
        @ReadWrite(bits: 8..<9)
        var endtx: ENDTX

        /// Write '1' to enable interrupt for event STARTED
        @ReadWrite(bits: 19..<20)
        var started: STARTED
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event STOPPED
        @ReadWrite(bits: 1..<2)
        var stopped: STOPPED

        /// Write '1' to disable interrupt for event ENDRX
        @ReadWrite(bits: 4..<5)
        var endrx: ENDRX

        /// Write '1' to disable interrupt for event END
        @ReadWrite(bits: 6..<7)
        var end: END

        /// Write '1' to disable interrupt for event ENDTX
        @ReadWrite(bits: 8..<9)
        var endtx: ENDTX

        /// Write '1' to disable interrupt for event STARTED
        @ReadWrite(bits: 19..<20)
        var started: STARTED
    }

    /// Stall status for EasyDMA RAM accesses. The fields in this register are set to STALL by hardware whenever a stall occurs and can be cleared (set to NOSTALL) by the CPU.
    @Register(bitWidth: 32)
    struct STALLSTAT {
        /// Stall status for EasyDMA RAM reads
        @ReadWrite(bits: 0..<1, as: TXValues.self)
        var tx: TX

        /// Stall status for EasyDMA RAM writes
        @ReadWrite(bits: 1..<2, as: RXValues.self)
        var rx: RX
    }

    /// Enable SPIM
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable or disable SPIM
        @ReadWrite(bits: 0..<4, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// SPI frequency. Accuracy depends on the HFCLK source selected.
    @Register(bitWidth: 32)
    struct FREQUENCY {
        /// SPI master data rate
        @ReadWrite(bits: 0..<32, as: FREQUENCY_FIELDValues.self)
        var frequency_field: FREQUENCY_FIELD
    }

    /// Configuration register
    @Register(bitWidth: 32)
    struct CONFIG {
        /// Bit order
        @ReadWrite(bits: 0..<1, as: ORDERValues.self)
        var order: ORDER

        /// Serial clock (SCK) phase
        @ReadWrite(bits: 1..<2, as: CPHAValues.self)
        var cpha: CPHA

        /// Serial clock (SCK) polarity
        @ReadWrite(bits: 2..<3, as: CPOLValues.self)
        var cpol: CPOL
    }

    /// Polarity of CSN output
    @Register(bitWidth: 32)
    struct CSNPOL {
        /// Polarity of CSN output
        @ReadWrite(bits: 0..<1, as: CSNPOL_FIELDValues.self)
        var csnpol_field: CSNPOL_FIELD
    }

    /// Pin select for DCX signal
    @Register(bitWidth: 32)
    struct PSELDCX {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// DCX configuration
    @Register(bitWidth: 32)
    struct DCXCNT {
        /// This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes.
        @ReadWrite(bits: 0..<4)
        var dcxcnt_field: DCXCNT_FIELD
    }

    /// Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
    @Register(bitWidth: 32)
    struct ORC {
        /// Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT.
        @ReadWrite(bits: 0..<8)
        var orc_field: ORC_FIELD
    }

    /// Unspecified
    @RegisterBlock
    struct PSEL {
        /// Pin select for SCK
        @RegisterBlock(offset: 0x0)
        var sck: Register<SCK>

        /// Pin select for MOSI signal
        @RegisterBlock(offset: 0x4)
        var mosi: Register<MOSI>

        /// Pin select for MISO signal
        @RegisterBlock(offset: 0x8)
        var miso: Register<MISO>

        /// Pin select for CSN
        @RegisterBlock(offset: 0xc)
        var csn: Register<CSN>
    }

    /// RXD EasyDMA channel
    @RegisterBlock
    struct RXD {
        /// Data pointer
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>

        /// Maximum number of bytes in receive buffer
        @RegisterBlock(offset: 0x4)
        var maxcnt: Register<MAXCNT>

        /// Number of bytes transferred in the last transaction
        @RegisterBlock(offset: 0x8)
        var amount: Register<AMOUNT>

        /// EasyDMA list type
        @RegisterBlock(offset: 0xc)
        var list: Register<LIST>
    }

    /// TXD EasyDMA channel
    @RegisterBlock
    struct TXD {
        /// Data pointer
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>

        /// Number of bytes in transmit buffer
        @RegisterBlock(offset: 0x4)
        var maxcnt: Register<MAXCNT>

        /// Number of bytes transferred in the last transaction
        @RegisterBlock(offset: 0x8)
        var amount: Register<AMOUNT>

        /// EasyDMA list type
        @RegisterBlock(offset: 0xc)
        var list: Register<LIST>
    }

    /// Unspecified
    @RegisterBlock
    struct IFTIMING {
        /// Sample delay for input serial data on MISO
        @RegisterBlock(offset: 0x0)
        var rxdelay: Register<RXDELAY>

        /// Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions
        @RegisterBlock(offset: 0x4)
        var csndur: Register<CSNDUR>
    }
}

extension SPIM0.PSEL {
    /// Pin select for SCK
    @Register(bitWidth: 32)
    struct SCK {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for MOSI signal
    @Register(bitWidth: 32)
    struct MOSI {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for MISO signal
    @Register(bitWidth: 32)
    struct MISO {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for CSN
    @Register(bitWidth: 32)
    struct CSN {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }
}

extension SPIM0.RXD {
    /// Data pointer
    @Register(bitWidth: 32)
    struct PTR {
        /// Data pointer
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }

    /// Maximum number of bytes in receive buffer
    @Register(bitWidth: 32)
    struct MAXCNT {
        /// Maximum number of bytes in receive buffer
        @ReadWrite(bits: 0..<16)
        var maxcnt_field: MAXCNT_FIELD
    }

    /// Number of bytes transferred in the last transaction
    @Register(bitWidth: 32)
    struct AMOUNT {
        /// Number of bytes transferred in the last transaction
        @ReadOnly(bits: 0..<16)
        var amount_field: AMOUNT_FIELD
    }

    /// EasyDMA list type
    @Register(bitWidth: 32)
    struct LIST {
        /// List type
        @ReadWrite(bits: 0..<2, as: LIST_FIELDValues.self)
        var list_field: LIST_FIELD
    }
}

extension SPIM0.TXD {
    /// Data pointer
    @Register(bitWidth: 32)
    struct PTR {
        /// Data pointer
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }

    /// Number of bytes in transmit buffer
    @Register(bitWidth: 32)
    struct MAXCNT {
        /// Maximum number of bytes in transmit buffer
        @ReadWrite(bits: 0..<16)
        var maxcnt_field: MAXCNT_FIELD
    }

    /// Number of bytes transferred in the last transaction
    @Register(bitWidth: 32)
    struct AMOUNT {
        /// Number of bytes transferred in the last transaction
        @ReadOnly(bits: 0..<16)
        var amount_field: AMOUNT_FIELD
    }

    /// EasyDMA list type
    @Register(bitWidth: 32)
    struct LIST {
        /// List type
        @ReadWrite(bits: 0..<2, as: LIST_FIELDValues.self)
        var list_field: LIST_FIELD
    }
}

extension SPIM0.IFTIMING {
    /// Sample delay for input serial data on MISO
    @Register(bitWidth: 32)
    struct RXDELAY {
        /// Sample delay for input serial data on MISO. The value specifies the number of 64 MHz clock cycles (15.625 ns) delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK.
        @ReadWrite(bits: 0..<3)
        var rxdelay_field: RXDELAY_FIELD
    }

    /// Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions
    @Register(bitWidth: 32)
    struct CSNDUR {
        /// Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions. The value is specified in number of 64 MHz clock cycles (15.625 ns).
        @ReadWrite(bits: 0..<8)
        var csndur_field: CSNDUR_FIELD
    }
}

extension SPIM0.TASKS_START {
    struct TASKS_START_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.TASKS_SUSPEND {
    struct TASKS_SUSPEND_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.TASKS_RESUME {
    struct TASKS_RESUME_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.EVENTS_STOPPED {
    struct EVENTS_STOPPED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.EVENTS_ENDRX {
    struct EVENTS_ENDRX_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.EVENTS_END {
    struct EVENTS_END_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.EVENTS_ENDTX {
    struct EVENTS_ENDTX_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.EVENTS_STARTED {
    struct EVENTS_STARTED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.SHORTS {
    struct END_STARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.STALLSTAT {
    struct TXValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// No stall
        static let NOSTALL = Self(rawValue: 0x0)

        /// A stall has occurred
        static let STALL = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.STALLSTAT {
    struct RXValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// No stall
        static let NOSTALL = Self(rawValue: 0x0)

        /// A stall has occurred
        static let STALL = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// Disable SPIM
        static let Disabled = Self(rawValue: 0x0)

        /// Enable SPIM
        static let Enabled = Self(rawValue: 0x7)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.FREQUENCY {
    struct FREQUENCY_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 32

        /// 125 kbps
        static let K125 = Self(rawValue: 0x2000000)

        /// 250 kbps
        static let K250 = Self(rawValue: 0x4000000)

        /// 500 kbps
        static let K500 = Self(rawValue: 0x8000000)

        /// 1 Mbps
        static let M1 = Self(rawValue: 0x10000000)

        /// 2 Mbps
        static let M2 = Self(rawValue: 0x20000000)

        /// 4 Mbps
        static let M4 = Self(rawValue: 0x40000000)

        /// 8 Mbps
        static let M8 = Self(rawValue: 0x80000000)

        /// 16 Mbps
        static let M16 = Self(rawValue: 0xa000000)

        /// 32 Mbps
        static let M32 = Self(rawValue: 0x14000000)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.CONFIG {
    struct ORDERValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Most significant bit shifted out first
        static let MsbFirst = Self(rawValue: 0x0)

        /// Least significant bit shifted out first
        static let LsbFirst = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.CONFIG {
    struct CPHAValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Sample on leading edge of clock, shift serial data on trailing edge
        static let Leading = Self(rawValue: 0x0)

        /// Sample on trailing edge of clock, shift serial data on leading edge
        static let Trailing = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.CONFIG {
    struct CPOLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Active high
        static let ActiveHigh = Self(rawValue: 0x0)

        /// Active low
        static let ActiveLow = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.CSNPOL {
    struct CSNPOL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Active low (idle state high)
        static let LOW = Self(rawValue: 0x0)

        /// Active high (idle state low)
        static let HIGH = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.PSELDCX {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.PSEL.SCK {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.PSEL.MOSI {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.PSEL.MISO {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.PSEL.CSN {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.RXD.LIST {
    struct LIST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Disable EasyDMA list
        static let Disabled = Self(rawValue: 0x0)

        /// Use array list
        static let ArrayList = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SPIM0.TXD.LIST {
    struct LIST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Disable EasyDMA list
        static let Disabled = Self(rawValue: 0x0)

        /// Use array list
        static let ArrayList = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
