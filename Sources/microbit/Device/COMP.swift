// Generated by svd2swift.

import MMIO

/// Comparator
@RegisterBlock
struct COMP {
    /// Start comparator
    @RegisterBlock(offset: 0x0)
    var tasks_start: Register<TASKS_START>

    /// Stop comparator
    @RegisterBlock(offset: 0x4)
    var tasks_stop: Register<TASKS_STOP>

    /// Sample comparator value
    @RegisterBlock(offset: 0x8)
    var tasks_sample: Register<TASKS_SAMPLE>

    /// COMP is ready and output is valid
    @RegisterBlock(offset: 0x100)
    var events_ready: Register<EVENTS_READY>

    /// Downward crossing
    @RegisterBlock(offset: 0x104)
    var events_down: Register<EVENTS_DOWN>

    /// Upward crossing
    @RegisterBlock(offset: 0x108)
    var events_up: Register<EVENTS_UP>

    /// Downward or upward crossing
    @RegisterBlock(offset: 0x10c)
    var events_cross: Register<EVENTS_CROSS>

    /// Shortcuts between local events and tasks
    @RegisterBlock(offset: 0x200)
    var shorts: Register<SHORTS>

    /// Enable or disable interrupt
    @RegisterBlock(offset: 0x300)
    var inten: Register<INTEN>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// Compare result
    @RegisterBlock(offset: 0x400)
    var result: Register<RESULT>

    /// COMP enable
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// Pin select
    @RegisterBlock(offset: 0x504)
    var psel: Register<PSEL>

    /// Reference source select for single-ended mode
    @RegisterBlock(offset: 0x508)
    var refsel: Register<REFSEL>

    /// External reference select
    @RegisterBlock(offset: 0x50c)
    var extrefsel: Register<EXTREFSEL>

    /// Threshold configuration for hysteresis unit
    @RegisterBlock(offset: 0x530)
    var th: Register<TH>

    /// Mode configuration
    @RegisterBlock(offset: 0x534)
    var mode: Register<MODE>

    /// Comparator hysteresis enable
    @RegisterBlock(offset: 0x538)
    var hyst: Register<HYST>
}

extension COMP {
    /// Start comparator
    @Register(bitWidth: 32)
    struct TASKS_START {
        /// Start comparator
        @WriteOnly(bits: 0..<1, as: TASKS_START_FIELDValues.self)
        var tasks_start_field: TASKS_START_FIELD
    }

    /// Stop comparator
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stop comparator
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// Sample comparator value
    @Register(bitWidth: 32)
    struct TASKS_SAMPLE {
        /// Sample comparator value
        @WriteOnly(bits: 0..<1, as: TASKS_SAMPLE_FIELDValues.self)
        var tasks_sample_field: TASKS_SAMPLE_FIELD
    }

    /// COMP is ready and output is valid
    @Register(bitWidth: 32)
    struct EVENTS_READY {
        /// COMP is ready and output is valid
        @ReadWrite(bits: 0..<1, as: EVENTS_READY_FIELDValues.self)
        var events_ready_field: EVENTS_READY_FIELD
    }

    /// Downward crossing
    @Register(bitWidth: 32)
    struct EVENTS_DOWN {
        /// Downward crossing
        @ReadWrite(bits: 0..<1, as: EVENTS_DOWN_FIELDValues.self)
        var events_down_field: EVENTS_DOWN_FIELD
    }

    /// Upward crossing
    @Register(bitWidth: 32)
    struct EVENTS_UP {
        /// Upward crossing
        @ReadWrite(bits: 0..<1, as: EVENTS_UP_FIELDValues.self)
        var events_up_field: EVENTS_UP_FIELD
    }

    /// Downward or upward crossing
    @Register(bitWidth: 32)
    struct EVENTS_CROSS {
        /// Downward or upward crossing
        @ReadWrite(bits: 0..<1, as: EVENTS_CROSS_FIELDValues.self)
        var events_cross_field: EVENTS_CROSS_FIELD
    }

    /// Shortcuts between local events and tasks
    @Register(bitWidth: 32)
    struct SHORTS {
        /// Shortcut between event READY and task SAMPLE
        @ReadWrite(bits: 0..<1, as: READY_SAMPLEValues.self)
        var ready_sample: READY_SAMPLE

        /// Shortcut between event READY and task STOP
        @ReadWrite(bits: 1..<2, as: READY_STOPValues.self)
        var ready_stop: READY_STOP

        /// Shortcut between event DOWN and task STOP
        @ReadWrite(bits: 2..<3, as: DOWN_STOPValues.self)
        var down_stop: DOWN_STOP

        /// Shortcut between event UP and task STOP
        @ReadWrite(bits: 3..<4, as: UP_STOPValues.self)
        var up_stop: UP_STOP

        /// Shortcut between event CROSS and task STOP
        @ReadWrite(bits: 4..<5, as: CROSS_STOPValues.self)
        var cross_stop: CROSS_STOP
    }

    /// Enable or disable interrupt
    @Register(bitWidth: 32)
    struct INTEN {
        /// Enable or disable interrupt for event READY
        @ReadWrite(bits: 0..<1, as: READYValues.self)
        var ready: READY

        /// Enable or disable interrupt for event DOWN
        @ReadWrite(bits: 1..<2, as: DOWNValues.self)
        var down: DOWN

        /// Enable or disable interrupt for event UP
        @ReadWrite(bits: 2..<3, as: UPValues.self)
        var up: UP

        /// Enable or disable interrupt for event CROSS
        @ReadWrite(bits: 3..<4, as: CROSSValues.self)
        var cross: CROSS
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event READY
        @ReadWrite(bits: 0..<1)
        var ready: READY

        /// Write '1' to enable interrupt for event DOWN
        @ReadWrite(bits: 1..<2)
        var down: DOWN

        /// Write '1' to enable interrupt for event UP
        @ReadWrite(bits: 2..<3)
        var up: UP

        /// Write '1' to enable interrupt for event CROSS
        @ReadWrite(bits: 3..<4)
        var cross: CROSS
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event READY
        @ReadWrite(bits: 0..<1)
        var ready: READY

        /// Write '1' to disable interrupt for event DOWN
        @ReadWrite(bits: 1..<2)
        var down: DOWN

        /// Write '1' to disable interrupt for event UP
        @ReadWrite(bits: 2..<3)
        var up: UP

        /// Write '1' to disable interrupt for event CROSS
        @ReadWrite(bits: 3..<4)
        var cross: CROSS
    }

    /// Compare result
    @Register(bitWidth: 32)
    struct RESULT {
        /// Result of last compare. Decision point SAMPLE task.
        @ReadOnly(bits: 0..<1, as: RESULT_FIELDValues.self)
        var result_field: RESULT_FIELD
    }

    /// COMP enable
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable or disable COMP
        @ReadWrite(bits: 0..<2, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// Pin select
    @Register(bitWidth: 32)
    struct PSEL {
        /// Analog pin select
        @ReadWrite(bits: 0..<3, as: PSEL_FIELDValues.self)
        var psel_field: PSEL_FIELD
    }

    /// Reference source select for single-ended mode
    @Register(bitWidth: 32)
    struct REFSEL {
        /// Reference select
        @ReadWrite(bits: 0..<3, as: REFSEL_FIELDValues.self)
        var refsel_field: REFSEL_FIELD
    }

    /// External reference select
    @Register(bitWidth: 32)
    struct EXTREFSEL {
        /// External analog reference select
        @ReadWrite(bits: 0..<3, as: EXTREFSEL_FIELDValues.self)
        var extrefsel_field: EXTREFSEL_FIELD
    }

    /// Threshold configuration for hysteresis unit
    @Register(bitWidth: 32)
    struct TH {
        /// VDOWN = (THDOWN+1)/64*VREF
        @ReadWrite(bits: 0..<6)
        var thdown: THDOWN

        /// VUP = (THUP+1)/64*VREF
        @ReadWrite(bits: 8..<14)
        var thup: THUP
    }

    /// Mode configuration
    @Register(bitWidth: 32)
    struct MODE {
        /// Speed and power modes
        @ReadWrite(bits: 0..<2, as: SPValues.self)
        var sp: SP

        /// Main operation modes
        @ReadWrite(bits: 8..<9, as: MAINValues.self)
        var main: MAIN
    }

    /// Comparator hysteresis enable
    @Register(bitWidth: 32)
    struct HYST {
        /// Comparator hysteresis
        @ReadWrite(bits: 0..<1, as: HYST_FIELDValues.self)
        var hyst_field: HYST_FIELD
    }
}

extension COMP.TASKS_START {
    struct TASKS_START_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.TASKS_SAMPLE {
    struct TASKS_SAMPLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.EVENTS_READY {
    struct EVENTS_READY_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.EVENTS_DOWN {
    struct EVENTS_DOWN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.EVENTS_UP {
    struct EVENTS_UP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.EVENTS_CROSS {
    struct EVENTS_CROSS_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.SHORTS {
    struct READY_SAMPLEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.SHORTS {
    struct READY_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.SHORTS {
    struct DOWN_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.SHORTS {
    struct UP_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.SHORTS {
    struct CROSS_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.INTEN {
    struct READYValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.INTEN {
    struct DOWNValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.INTEN {
    struct UPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.INTEN {
    struct CROSSValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.RESULT {
    struct RESULT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// lt; VIN-)
        static let Below = Self(rawValue: 0x0)

        /// gt; VIN-)
        static let Above = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.PSEL {
    struct PSEL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// AIN0 selected as analog input
        static let AnalogInput0 = Self(rawValue: 0x0)

        /// AIN1 selected as analog input
        static let AnalogInput1 = Self(rawValue: 0x1)

        /// AIN2 selected as analog input
        static let AnalogInput2 = Self(rawValue: 0x2)

        /// AIN3 selected as analog input
        static let AnalogInput3 = Self(rawValue: 0x3)

        /// AIN4 selected as analog input
        static let AnalogInput4 = Self(rawValue: 0x4)

        /// AIN5 selected as analog input
        static let AnalogInput5 = Self(rawValue: 0x5)

        /// AIN6 selected as analog input
        static let AnalogInput6 = Self(rawValue: 0x6)

        /// AIN7 selected as analog input
        static let AnalogInput7 = Self(rawValue: 0x7)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.REFSEL {
    struct REFSEL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// gt;= 1.7 V)
        static let Int1V2 = Self(rawValue: 0x0)

        /// gt;= VREF + 0.2 V)
        static let Int1V8 = Self(rawValue: 0x1)

        /// gt;= VREF + 0.2 V)
        static let Int2V4 = Self(rawValue: 0x2)

        /// VREF = VDD
        static let VDD = Self(rawValue: 0x4)

        /// VREF = AREF
        static let ARef = Self(rawValue: 0x5)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.EXTREFSEL {
    struct EXTREFSEL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// Use AIN0 as external analog reference
        static let AnalogReference0 = Self(rawValue: 0x0)

        /// Use AIN1 as external analog reference
        static let AnalogReference1 = Self(rawValue: 0x1)

        /// Use AIN2 as external analog reference
        static let AnalogReference2 = Self(rawValue: 0x2)

        /// Use AIN3 as external analog reference
        static let AnalogReference3 = Self(rawValue: 0x3)

        /// Use AIN4 as external analog reference
        static let AnalogReference4 = Self(rawValue: 0x4)

        /// Use AIN5 as external analog reference
        static let AnalogReference5 = Self(rawValue: 0x5)

        /// Use AIN6 as external analog reference
        static let AnalogReference6 = Self(rawValue: 0x6)

        /// Use AIN7 as external analog reference
        static let AnalogReference7 = Self(rawValue: 0x7)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.MODE {
    struct SPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Low-power mode
        static let Low = Self(rawValue: 0x0)

        /// Normal mode
        static let Normal = Self(rawValue: 0x1)

        /// High-speed mode
        static let High = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.MODE {
    struct MAINValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Single-ended mode
        static let SE = Self(rawValue: 0x0)

        /// Differential mode
        static let Diff = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension COMP.HYST {
    struct HYST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Comparator hysteresis disabled
        static let NoHyst = Self(rawValue: 0x0)

        /// Comparator hysteresis enabled
        static let Hyst50mV = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
