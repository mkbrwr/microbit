// Generated by svd2swift.

import MMIO

/// Factory information configuration registers
@RegisterBlock
struct FICR {
    /// Code memory page size
    @RegisterBlock(offset: 0x10)
    var codepagesize: Register<CODEPAGESIZE>

    /// Code memory size
    @RegisterBlock(offset: 0x14)
    var codesize: Register<CODESIZE>

    /// Description collection: Device identifier
    @RegisterBlock(offset: 0x60, stride: 0x4, count: 2)
    var deviceid: RegisterArray<DEVICEID>

    /// Description collection: Encryption root, word n
    @RegisterBlock(offset: 0x80, stride: 0x4, count: 4)
    var er: RegisterArray<ER>

    /// Description collection: Identity Root, word n
    @RegisterBlock(offset: 0x90, stride: 0x4, count: 4)
    var ir: RegisterArray<IR>

    /// Device address type
    @RegisterBlock(offset: 0xa0)
    var deviceaddrtype: Register<DEVICEADDRTYPE>

    /// Description collection: Device address n
    @RegisterBlock(offset: 0xa4, stride: 0x4, count: 2)
    var deviceaddr: RegisterArray<DEVICEADDR>

    /// Description collection: Production test signature n
    @RegisterBlock(offset: 0x350, stride: 0x4, count: 3)
    var prodtest: RegisterArray<PRODTEST>

    /// Device info
    @RegisterBlock(offset: 0x100)
    var info: INFO

    /// Registers storing factory TEMP module linearization coefficients
    @RegisterBlock(offset: 0x404)
    var temp: TEMP

    /// Unspecified
    @RegisterBlock(offset: 0x450)
    var nfc: NFC
}

extension FICR {
    /// Code memory page size
    @Register(bitWidth: 32)
    struct CODEPAGESIZE {
        /// Code memory page size
        @ReadOnly(bits: 0..<32)
        var codepagesize_field: CODEPAGESIZE_FIELD
    }

    /// Code memory size
    @Register(bitWidth: 32)
    struct CODESIZE {
        /// Code memory size in number of pages
        @ReadOnly(bits: 0..<32)
        var codesize_field: CODESIZE_FIELD
    }

    /// Description collection: Device identifier
    @Register(bitWidth: 32)
    struct DEVICEID {
        /// 64 bit unique device identifier
        @ReadOnly(bits: 0..<32)
        var deviceid_field: DEVICEID_FIELD
    }

    /// Description collection: Encryption root, word n
    @Register(bitWidth: 32)
    struct ER {
        /// Encryption root, word n
        @ReadOnly(bits: 0..<32)
        var er_field: ER_FIELD
    }

    /// Description collection: Identity Root, word n
    @Register(bitWidth: 32)
    struct IR {
        /// Identity Root, word n
        @ReadOnly(bits: 0..<32)
        var ir_field: IR_FIELD
    }

    /// Device address type
    @Register(bitWidth: 32)
    struct DEVICEADDRTYPE {
        /// Device address type
        @ReadOnly(bits: 0..<1, as: DEVICEADDRTYPE_FIELDValues.self)
        var deviceaddrtype_field: DEVICEADDRTYPE_FIELD
    }

    /// Description collection: Device address n
    @Register(bitWidth: 32)
    struct DEVICEADDR {
        /// 48 bit device address
        @ReadOnly(bits: 0..<32)
        var deviceaddr_field: DEVICEADDR_FIELD
    }

    /// Description collection: Production test signature n
    @Register(bitWidth: 32)
    struct PRODTEST {
        /// Production test signature n
        @ReadOnly(bits: 0..<32, as: PRODTEST_FIELDValues.self)
        var prodtest_field: PRODTEST_FIELD
    }

    /// Device info
    @RegisterBlock
    struct INFO {
        /// Part code
        @RegisterBlock(offset: 0x0)
        var part: Register<PART>

        /// Build code (hardware version and production configuration)
        @RegisterBlock(offset: 0x4)
        var variant: Register<VARIANT>

        /// Package option
        @RegisterBlock(offset: 0x8)
        var `package`: Register<PACKAGE>

        /// RAM variant
        @RegisterBlock(offset: 0xc)
        var ram: Register<RAM>

        /// Flash variant
        @RegisterBlock(offset: 0x10)
        var flash: Register<FLASH>
    }

    /// Registers storing factory TEMP module linearization coefficients
    @RegisterBlock
    struct TEMP {
        /// Slope definition A0
        @RegisterBlock(offset: 0x0)
        var a0: Register<A0>

        /// Slope definition A1
        @RegisterBlock(offset: 0x4)
        var a1: Register<A1>

        /// Slope definition A2
        @RegisterBlock(offset: 0x8)
        var a2: Register<A2>

        /// Slope definition A3
        @RegisterBlock(offset: 0xc)
        var a3: Register<A3>

        /// Slope definition A4
        @RegisterBlock(offset: 0x10)
        var a4: Register<A4>

        /// Slope definition A5
        @RegisterBlock(offset: 0x14)
        var a5: Register<A5>

        /// Y-intercept B0
        @RegisterBlock(offset: 0x18)
        var b0: Register<B0>

        /// Y-intercept B1
        @RegisterBlock(offset: 0x1c)
        var b1: Register<B1>

        /// Y-intercept B2
        @RegisterBlock(offset: 0x20)
        var b2: Register<B2>

        /// Y-intercept B3
        @RegisterBlock(offset: 0x24)
        var b3: Register<B3>

        /// Y-intercept B4
        @RegisterBlock(offset: 0x28)
        var b4: Register<B4>

        /// Y-intercept B5
        @RegisterBlock(offset: 0x2c)
        var b5: Register<B5>

        /// Segment end T0
        @RegisterBlock(offset: 0x30)
        var t0: Register<T0>

        /// Segment end T1
        @RegisterBlock(offset: 0x34)
        var t1: Register<T1>

        /// Segment end T2
        @RegisterBlock(offset: 0x38)
        var t2: Register<T2>

        /// Segment end T3
        @RegisterBlock(offset: 0x3c)
        var t3: Register<T3>

        /// Segment end T4
        @RegisterBlock(offset: 0x40)
        var t4: Register<T4>
    }

    /// Unspecified
    @RegisterBlock
    struct NFC {
        /// Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
        @RegisterBlock(offset: 0x0)
        var tagheader0: Register<TAGHEADER0>

        /// Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
        @RegisterBlock(offset: 0x4)
        var tagheader1: Register<TAGHEADER1>

        /// Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
        @RegisterBlock(offset: 0x8)
        var tagheader2: Register<TAGHEADER2>

        /// Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
        @RegisterBlock(offset: 0xc)
        var tagheader3: Register<TAGHEADER3>
    }
}

extension FICR.INFO {
    /// Part code
    @Register(bitWidth: 32)
    struct PART {
        /// Part code
        @ReadOnly(bits: 0..<32, as: PART_FIELDValues.self)
        var part_field: PART_FIELD
    }

    /// Build code (hardware version and production configuration)
    @Register(bitWidth: 32)
    struct VARIANT {
        /// Build code (hardware version and production configuration). Encoded as ASCII.
        @ReadOnly(bits: 0..<32, as: VARIANT_FIELDValues.self)
        var variant_field: VARIANT_FIELD
    }

    /// Package option
    @Register(bitWidth: 32)
    struct PACKAGE {
        /// Package option
        @ReadOnly(bits: 0..<32, as: PACKAGE_FIELDValues.self)
        var package_field: PACKAGE_FIELD
    }

    /// RAM variant
    @Register(bitWidth: 32)
    struct RAM {
        /// RAM variant
        @ReadOnly(bits: 0..<32, as: RAM_FIELDValues.self)
        var ram_field: RAM_FIELD
    }

    /// Flash variant
    @Register(bitWidth: 32)
    struct FLASH {
        /// Flash variant
        @ReadOnly(bits: 0..<32, as: FLASH_FIELDValues.self)
        var flash_field: FLASH_FIELD
    }
}

extension FICR.TEMP {
    /// Slope definition A0
    @Register(bitWidth: 32)
    struct A0 {
        /// A (slope definition) register.
        @ReadOnly(bits: 0..<12)
        var a: A
    }

    /// Slope definition A1
    @Register(bitWidth: 32)
    struct A1 {
        /// A (slope definition) register.
        @ReadOnly(bits: 0..<12)
        var a: A
    }

    /// Slope definition A2
    @Register(bitWidth: 32)
    struct A2 {
        /// A (slope definition) register.
        @ReadOnly(bits: 0..<12)
        var a: A
    }

    /// Slope definition A3
    @Register(bitWidth: 32)
    struct A3 {
        /// A (slope definition) register.
        @ReadOnly(bits: 0..<12)
        var a: A
    }

    /// Slope definition A4
    @Register(bitWidth: 32)
    struct A4 {
        /// A (slope definition) register.
        @ReadOnly(bits: 0..<12)
        var a: A
    }

    /// Slope definition A5
    @Register(bitWidth: 32)
    struct A5 {
        /// A (slope definition) register.
        @ReadOnly(bits: 0..<12)
        var a: A
    }

    /// Y-intercept B0
    @Register(bitWidth: 32)
    struct B0 {
        /// B (y-intercept)
        @ReadOnly(bits: 0..<14)
        var b: B
    }

    /// Y-intercept B1
    @Register(bitWidth: 32)
    struct B1 {
        /// B (y-intercept)
        @ReadOnly(bits: 0..<14)
        var b: B
    }

    /// Y-intercept B2
    @Register(bitWidth: 32)
    struct B2 {
        /// B (y-intercept)
        @ReadOnly(bits: 0..<14)
        var b: B
    }

    /// Y-intercept B3
    @Register(bitWidth: 32)
    struct B3 {
        /// B (y-intercept)
        @ReadOnly(bits: 0..<14)
        var b: B
    }

    /// Y-intercept B4
    @Register(bitWidth: 32)
    struct B4 {
        /// B (y-intercept)
        @ReadOnly(bits: 0..<14)
        var b: B
    }

    /// Y-intercept B5
    @Register(bitWidth: 32)
    struct B5 {
        /// B (y-intercept)
        @ReadOnly(bits: 0..<14)
        var b: B
    }

    /// Segment end T0
    @Register(bitWidth: 32)
    struct T0 {
        /// T (segment end) register
        @ReadOnly(bits: 0..<8)
        var t: T
    }

    /// Segment end T1
    @Register(bitWidth: 32)
    struct T1 {
        /// T (segment end) register
        @ReadOnly(bits: 0..<8)
        var t: T
    }

    /// Segment end T2
    @Register(bitWidth: 32)
    struct T2 {
        /// T (segment end) register
        @ReadOnly(bits: 0..<8)
        var t: T
    }

    /// Segment end T3
    @Register(bitWidth: 32)
    struct T3 {
        /// T (segment end) register
        @ReadOnly(bits: 0..<8)
        var t: T
    }

    /// Segment end T4
    @Register(bitWidth: 32)
    struct T4 {
        /// T (segment end) register
        @ReadOnly(bits: 0..<8)
        var t: T
    }
}

extension FICR.NFC {
    /// Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
    @Register(bitWidth: 32)
    struct TAGHEADER0 {
        /// Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F
        @ReadOnly(bits: 0..<8)
        var mfgid: MFGID

        /// Unique identifier byte 1
        @ReadOnly(bits: 8..<16)
        var ud1: UD1

        /// Unique identifier byte 2
        @ReadOnly(bits: 16..<24)
        var ud2: UD2

        /// Unique identifier byte 3
        @ReadOnly(bits: 24..<32)
        var ud3: UD3
    }

    /// Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
    @Register(bitWidth: 32)
    struct TAGHEADER1 {
        /// Unique identifier byte 4
        @ReadOnly(bits: 0..<8)
        var ud4: UD4

        /// Unique identifier byte 5
        @ReadOnly(bits: 8..<16)
        var ud5: UD5

        /// Unique identifier byte 6
        @ReadOnly(bits: 16..<24)
        var ud6: UD6

        /// Unique identifier byte 7
        @ReadOnly(bits: 24..<32)
        var ud7: UD7
    }

    /// Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
    @Register(bitWidth: 32)
    struct TAGHEADER2 {
        /// Unique identifier byte 8
        @ReadOnly(bits: 0..<8)
        var ud8: UD8

        /// Unique identifier byte 9
        @ReadOnly(bits: 8..<16)
        var ud9: UD9

        /// Unique identifier byte 10
        @ReadOnly(bits: 16..<24)
        var ud10: UD10

        /// Unique identifier byte 11
        @ReadOnly(bits: 24..<32)
        var ud11: UD11
    }

    /// Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
    @Register(bitWidth: 32)
    struct TAGHEADER3 {
        /// Unique identifier byte 12
        @ReadOnly(bits: 0..<8)
        var ud12: UD12

        /// Unique identifier byte 13
        @ReadOnly(bits: 8..<16)
        var ud13: UD13

        /// Unique identifier byte 14
        @ReadOnly(bits: 16..<24)
        var ud14: UD14

        /// Unique identifier byte 15
        @ReadOnly(bits: 24..<32)
        var ud15: UD15
    }
}

extension FICR.DEVICEADDRTYPE {
    struct DEVICEADDRTYPE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Public address
        static let Public = Self(rawValue: 0x0)

        /// Random address
        static let Random = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FICR.PRODTEST {
    struct PRODTEST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 32

        /// Production tests done
        static let Done = Self(rawValue: 0xbb42319f)

        /// Production tests not done
        static let NotDone = Self(rawValue: 0xffffffff)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FICR.INFO.PART {
    struct PART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 32

        /// nRF52820
        static let N52820 = Self(rawValue: 0x52820)

        /// nRF52833
        static let N52833 = Self(rawValue: 0x52833)

        /// nRF52840
        static let N52840 = Self(rawValue: 0x52840)

        /// Unspecified
        static let Unspecified = Self(rawValue: 0xffffffff)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FICR.INFO.VARIANT {
    struct VARIANT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 32

        /// AAAA
        static let AAAA = Self(rawValue: 0x41414141)

        /// AAAB
        static let AAAB = Self(rawValue: 0x41414142)

        /// AAA0
        static let AAA0 = Self(rawValue: 0x41414130)

        /// AAA1
        static let AAA1 = Self(rawValue: 0x41414131)

        /// AAB0
        static let AAB0 = Self(rawValue: 0x41414230)

        /// Unspecified
        static let Unspecified = Self(rawValue: 0xffffffff)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FICR.INFO.PACKAGE {
    struct PACKAGE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 32

        /// QDxx - 5x5 40-pin QFN
        static let QD = Self(rawValue: 0x2007)

        /// QIxx - 7x7 73-pin aQFN
        static let QI = Self(rawValue: 0x2004)

        /// CJxx - 3.175 x 3.175 WLCSP
        static let CJ = Self(rawValue: 0x2008)

        /// Unspecified
        static let Unspecified = Self(rawValue: 0xffffffff)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FICR.INFO.RAM {
    struct RAM_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 32

        /// 16 kByte RAM
        static let K16 = Self(rawValue: 0x10)

        /// 32 kByte RAM
        static let K32 = Self(rawValue: 0x20)

        /// 64 kByte RAM
        static let K64 = Self(rawValue: 0x40)

        /// 128 kByte RAM
        static let K128 = Self(rawValue: 0x80)

        /// 256 kByte RAM
        static let K256 = Self(rawValue: 0x100)

        /// Unspecified
        static let Unspecified = Self(rawValue: 0xffffffff)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension FICR.INFO.FLASH {
    struct FLASH_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 32

        /// 128 kByte FLASH
        static let K128 = Self(rawValue: 0x80)

        /// 256 kByte FLASH
        static let K256 = Self(rawValue: 0x100)

        /// 512 kByte FLASH
        static let K512 = Self(rawValue: 0x200)

        /// 1 MByte FLASH
        static let K1024 = Self(rawValue: 0x400)

        /// 2 MByte FLASH
        static let K2048 = Self(rawValue: 0x800)

        /// Unspecified
        static let Unspecified = Self(rawValue: 0xffffffff)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
