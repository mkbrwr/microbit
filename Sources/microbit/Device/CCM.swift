// Generated by svd2swift.

import MMIO

/// AES CCM mode encryption
@RegisterBlock
struct CCM {
    /// Start generation of keystream. This operation will stop by itself when completed.
    @RegisterBlock(offset: 0x0)
    var tasks_ksgen: Register<TASKS_KSGEN>

    /// Start encryption/decryption. This operation will stop by itself when completed.
    @RegisterBlock(offset: 0x4)
    var tasks_crypt: Register<TASKS_CRYPT>

    /// Stop encryption/decryption
    @RegisterBlock(offset: 0x8)
    var tasks_stop: Register<TASKS_STOP>

    /// Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
    @RegisterBlock(offset: 0xc)
    var tasks_rateoverride: Register<TASKS_RATEOVERRIDE>

    /// Keystream generation complete
    @RegisterBlock(offset: 0x100)
    var events_endksgen: Register<EVENTS_ENDKSGEN>

    /// Encrypt/decrypt complete
    @RegisterBlock(offset: 0x104)
    var events_endcrypt: Register<EVENTS_ENDCRYPT>

    /// Deprecated register - CCM error event
    @RegisterBlock(offset: 0x108)
    var events_error: Register<EVENTS_ERROR>

    /// Shortcuts between local events and tasks
    @RegisterBlock(offset: 0x200)
    var shorts: Register<SHORTS>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// MIC check result
    @RegisterBlock(offset: 0x400)
    var micstatus: Register<MICSTATUS>

    /// Enable
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// Operation mode
    @RegisterBlock(offset: 0x504)
    var mode: Register<MODE>

    /// Pointer to data structure holding the AES key and the NONCE vector
    @RegisterBlock(offset: 0x508)
    var cnfptr: Register<CNFPTR>

    /// Input pointer
    @RegisterBlock(offset: 0x50c)
    var inptr: Register<INPTR>

    /// Output pointer
    @RegisterBlock(offset: 0x510)
    var outptr: Register<OUTPTR>

    /// Pointer to data area used for temporary storage
    @RegisterBlock(offset: 0x514)
    var scratchptr: Register<SCRATCHPTR>

    /// Length of keystream generated when MODE.LENGTH = Extended
    @RegisterBlock(offset: 0x518)
    var maxpacketsize: Register<MAXPACKETSIZE>

    /// Data rate override setting.
    @RegisterBlock(offset: 0x51c)
    var rateoverride: Register<RATEOVERRIDE>

    /// Header (S0) mask.
    @RegisterBlock(offset: 0x520)
    var headermask: Register<HEADERMASK>
}

extension CCM {
    /// Start generation of keystream. This operation will stop by itself when completed.
    @Register(bitWidth: 32)
    struct TASKS_KSGEN {
        /// Start generation of keystream. This operation will stop by itself when completed.
        @WriteOnly(bits: 0..<1, as: TASKS_KSGEN_FIELDValues.self)
        var tasks_ksgen_field: TASKS_KSGEN_FIELD
    }

    /// Start encryption/decryption. This operation will stop by itself when completed.
    @Register(bitWidth: 32)
    struct TASKS_CRYPT {
        /// Start encryption/decryption. This operation will stop by itself when completed.
        @WriteOnly(bits: 0..<1, as: TASKS_CRYPT_FIELDValues.self)
        var tasks_crypt_field: TASKS_CRYPT_FIELD
    }

    /// Stop encryption/decryption
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stop encryption/decryption
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
    @Register(bitWidth: 32)
    struct TASKS_RATEOVERRIDE {
        /// Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
        @WriteOnly(bits: 0..<1, as: TASKS_RATEOVERRIDE_FIELDValues.self)
        var tasks_rateoverride_field: TASKS_RATEOVERRIDE_FIELD
    }

    /// Keystream generation complete
    @Register(bitWidth: 32)
    struct EVENTS_ENDKSGEN {
        /// Keystream generation complete
        @ReadWrite(bits: 0..<1, as: EVENTS_ENDKSGEN_FIELDValues.self)
        var events_endksgen_field: EVENTS_ENDKSGEN_FIELD
    }

    /// Encrypt/decrypt complete
    @Register(bitWidth: 32)
    struct EVENTS_ENDCRYPT {
        /// Encrypt/decrypt complete
        @ReadWrite(bits: 0..<1, as: EVENTS_ENDCRYPT_FIELDValues.self)
        var events_endcrypt_field: EVENTS_ENDCRYPT_FIELD
    }

    /// Deprecated register - CCM error event
    @Register(bitWidth: 32)
    struct EVENTS_ERROR {
        /// Deprecated field - CCM error event
        @ReadWrite(bits: 0..<1, as: EVENTS_ERROR_FIELDValues.self)
        var events_error_field: EVENTS_ERROR_FIELD
    }

    /// Shortcuts between local events and tasks
    @Register(bitWidth: 32)
    struct SHORTS {
        /// Shortcut between event ENDKSGEN and task CRYPT
        @ReadWrite(bits: 0..<1, as: ENDKSGEN_CRYPTValues.self)
        var endksgen_crypt: ENDKSGEN_CRYPT
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event ENDKSGEN
        @ReadWrite(bits: 0..<1)
        var endksgen: ENDKSGEN

        /// Write '1' to enable interrupt for event ENDCRYPT
        @ReadWrite(bits: 1..<2)
        var endcrypt: ENDCRYPT

        /// Deprecated intsetfield - Write '1' to enable interrupt for event ERROR
        @ReadWrite(bits: 2..<3)
        var error: ERROR
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event ENDKSGEN
        @ReadWrite(bits: 0..<1)
        var endksgen: ENDKSGEN

        /// Write '1' to disable interrupt for event ENDCRYPT
        @ReadWrite(bits: 1..<2)
        var endcrypt: ENDCRYPT

        /// Deprecated intclrfield - Write '1' to disable interrupt for event ERROR
        @ReadWrite(bits: 2..<3)
        var error: ERROR
    }

    /// MIC check result
    @Register(bitWidth: 32)
    struct MICSTATUS {
        /// The result of the MIC check performed during the previous decryption operation
        @ReadOnly(bits: 0..<1, as: MICSTATUS_FIELDValues.self)
        var micstatus_field: MICSTATUS_FIELD
    }

    /// Enable
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable or disable CCM
        @ReadWrite(bits: 0..<2, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// Operation mode
    @Register(bitWidth: 32)
    struct MODE {
        /// The mode of operation to be used. Settings in this register apply whenever either the KSGEN task or the CRYPT task is triggered.
        @ReadWrite(bits: 0..<1, as: MODE_FIELDValues.self)
        var mode_field: MODE_FIELD

        /// Radio data rate that the CCM shall run synchronous with
        @ReadWrite(bits: 16..<18, as: DATARATEValues.self)
        var datarate: DATARATE

        /// Packet length configuration
        @ReadWrite(bits: 24..<25, as: LENGTHValues.self)
        var length: LENGTH
    }

    /// Pointer to data structure holding the AES key and the NONCE vector
    @Register(bitWidth: 32)
    struct CNFPTR {
        /// Pointer to the data structure holding the AES key and the CCM NONCE vector (see table CCM data structure overview)
        @ReadWrite(bits: 0..<32)
        var cnfptr_field: CNFPTR_FIELD
    }

    /// Input pointer
    @Register(bitWidth: 32)
    struct INPTR {
        /// Input pointer
        @ReadWrite(bits: 0..<32)
        var inptr_field: INPTR_FIELD
    }

    /// Output pointer
    @Register(bitWidth: 32)
    struct OUTPTR {
        /// Output pointer
        @ReadWrite(bits: 0..<32)
        var outptr_field: OUTPTR_FIELD
    }

    /// Pointer to data area used for temporary storage
    @Register(bitWidth: 32)
    struct SCRATCHPTR {
        /// MIC generation and encryption/decryption.
        @ReadWrite(bits: 0..<32)
        var scratchptr_field: SCRATCHPTR_FIELD
    }

    /// Length of keystream generated when MODE.LENGTH = Extended
    @Register(bitWidth: 32)
    struct MAXPACKETSIZE {
        /// Length of keystream generated when MODE.LENGTH = Extended. This value must be greater than or equal to the subsequent packet payload to be encrypted/decrypted.
        @ReadWrite(bits: 0..<8)
        var maxpacketsize_field: MAXPACKETSIZE_FIELD
    }

    /// Data rate override setting.
    @Register(bitWidth: 32)
    struct RATEOVERRIDE {
        /// Data rate override setting
        @ReadWrite(bits: 0..<2, as: RATEOVERRIDE_FIELDValues.self)
        var rateoverride_field: RATEOVERRIDE_FIELD
    }

    /// Header (S0) mask.
    @Register(bitWidth: 32)
    struct HEADERMASK {
        /// Header (S0) mask
        @ReadWrite(bits: 0..<8)
        var headermask_field: HEADERMASK_FIELD
    }
}

extension CCM.TASKS_KSGEN {
    struct TASKS_KSGEN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.TASKS_CRYPT {
    struct TASKS_CRYPT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.TASKS_RATEOVERRIDE {
    struct TASKS_RATEOVERRIDE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.EVENTS_ENDKSGEN {
    struct EVENTS_ENDKSGEN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.EVENTS_ENDCRYPT {
    struct EVENTS_ENDCRYPT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.EVENTS_ERROR {
    struct EVENTS_ERROR_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.SHORTS {
    struct ENDKSGEN_CRYPTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.MICSTATUS {
    struct MICSTATUS_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// MIC check failed
        static let CheckFailed = Self(rawValue: 0x0)

        /// MIC check passed
        static let CheckPassed = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.MODE {
    struct MODE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// AES CCM packet encryption mode
        static let Encryption = Self(rawValue: 0x0)

        /// AES CCM packet decryption mode
        static let Decryption = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.MODE {
    struct DATARATEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// 1 Mbps
        static let _1Mbit = Self(rawValue: 0x0)

        /// 2 Mbps
        static let _2Mbit = Self(rawValue: 0x1)

        /// 125 kbps
        static let _125Kbps = Self(rawValue: 0x2)

        /// 500 kbps
        static let _500Kbps = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.MODE {
    struct LENGTHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Default length. Effective length of LENGTH field in encrypted/decrypted packet is 5 bits. A keystream for packet payloads up to 27 bytes will be generated.
        static let Default = Self(rawValue: 0x0)

        /// Extended length. Effective length of LENGTH field in encrypted/decrypted packet is 8 bits. A keystream for packet payloads up to MAXPACKETSIZE bytes will be generated.
        static let Extended = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension CCM.RATEOVERRIDE {
    struct RATEOVERRIDE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// 1 Mbps
        static let _1Mbit = Self(rawValue: 0x0)

        /// 2 Mbps
        static let _2Mbit = Self(rawValue: 0x1)

        /// 125 kbps
        static let _125Kbps = Self(rawValue: 0x2)

        /// 500 kbps
        static let _500Kbps = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
