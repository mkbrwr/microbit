// Generated by svd2swift.

import MMIO

/// Successive approximation register (SAR) analog-to-digital converter
@RegisterBlock
struct SAADC {
    /// Starts the SAADC and prepares the result buffer in RAM
    @RegisterBlock(offset: 0x0)
    var tasks_start: Register<TASKS_START>

    /// Takes one SAADC sample
    @RegisterBlock(offset: 0x4)
    var tasks_sample: Register<TASKS_SAMPLE>

    /// Stops the SAADC and terminates all on-going conversions
    @RegisterBlock(offset: 0x8)
    var tasks_stop: Register<TASKS_STOP>

    /// Starts offset auto-calibration
    @RegisterBlock(offset: 0xc)
    var tasks_calibrateoffset: Register<TASKS_CALIBRATEOFFSET>

    /// The SAADC has started
    @RegisterBlock(offset: 0x100)
    var events_started: Register<EVENTS_STARTED>

    /// The SAADC has filled up the result buffer
    @RegisterBlock(offset: 0x104)
    var events_end: Register<EVENTS_END>

    /// A conversion task has been completed. Depending on the configuration, multiple conversions might be needed for a result to be transferred to RAM.
    @RegisterBlock(offset: 0x108)
    var events_done: Register<EVENTS_DONE>

    /// Result ready for transfer to RAM
    @RegisterBlock(offset: 0x10c)
    var events_resultdone: Register<EVENTS_RESULTDONE>

    /// Calibration is complete
    @RegisterBlock(offset: 0x110)
    var events_calibratedone: Register<EVENTS_CALIBRATEDONE>

    /// The SAADC has stopped
    @RegisterBlock(offset: 0x114)
    var events_stopped: Register<EVENTS_STOPPED>

    /// Enable or disable interrupt
    @RegisterBlock(offset: 0x300)
    var inten: Register<INTEN>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// Status
    @RegisterBlock(offset: 0x400)
    var status: Register<STATUS>

    /// Enable or disable SAADC
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// Resolution configuration
    @RegisterBlock(offset: 0x5f0)
    var resolution: Register<RESOLUTION>

    /// Oversampling configuration. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used.
    @RegisterBlock(offset: 0x5f4)
    var oversample: Register<OVERSAMPLE>

    /// Controls normal or continuous sample rate
    @RegisterBlock(offset: 0x5f8)
    var samplerate: Register<SAMPLERATE>

    /// Peripheral events.
    @RegisterBlock(offset: 0x118, stride: 0x8, count: 8)
    var events_ch: RegisterArray<EVENTS_CH>

    /// Unspecified
    @RegisterBlock(offset: 0x510, stride: 0x10, count: 8)
    var ch: RegisterArray<CH>

    /// RESULT EasyDMA channel
    @RegisterBlock(offset: 0x62c)
    var result: RESULT
}

extension SAADC {
    /// Starts the SAADC and prepares the result buffer in RAM
    @Register(bitWidth: 32)
    struct TASKS_START {
        /// Starts the SAADC and prepares the result buffer in RAM
        @WriteOnly(bits: 0..<1, as: TASKS_START_FIELDValues.self)
        var tasks_start_field: TASKS_START_FIELD
    }

    /// Takes one SAADC sample
    @Register(bitWidth: 32)
    struct TASKS_SAMPLE {
        /// Takes one SAADC sample
        @WriteOnly(bits: 0..<1, as: TASKS_SAMPLE_FIELDValues.self)
        var tasks_sample_field: TASKS_SAMPLE_FIELD
    }

    /// Stops the SAADC and terminates all on-going conversions
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stops the SAADC and terminates all on-going conversions
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// Starts offset auto-calibration
    @Register(bitWidth: 32)
    struct TASKS_CALIBRATEOFFSET {
        /// Starts offset auto-calibration
        @WriteOnly(bits: 0..<1, as: TASKS_CALIBRATEOFFSET_FIELDValues.self)
        var tasks_calibrateoffset_field: TASKS_CALIBRATEOFFSET_FIELD
    }

    /// The SAADC has started
    @Register(bitWidth: 32)
    struct EVENTS_STARTED {
        /// The SAADC has started
        @ReadWrite(bits: 0..<1, as: EVENTS_STARTED_FIELDValues.self)
        var events_started_field: EVENTS_STARTED_FIELD
    }

    /// The SAADC has filled up the result buffer
    @Register(bitWidth: 32)
    struct EVENTS_END {
        /// The SAADC has filled up the result buffer
        @ReadWrite(bits: 0..<1, as: EVENTS_END_FIELDValues.self)
        var events_end_field: EVENTS_END_FIELD
    }

    /// A conversion task has been completed. Depending on the configuration, multiple conversions might be needed for a result to be transferred to RAM.
    @Register(bitWidth: 32)
    struct EVENTS_DONE {
        /// A conversion task has been completed. Depending on the configuration, multiple conversions might be needed for a result to be transferred to RAM.
        @ReadWrite(bits: 0..<1, as: EVENTS_DONE_FIELDValues.self)
        var events_done_field: EVENTS_DONE_FIELD
    }

    /// Result ready for transfer to RAM
    @Register(bitWidth: 32)
    struct EVENTS_RESULTDONE {
        /// Result ready for transfer to RAM
        @ReadWrite(bits: 0..<1, as: EVENTS_RESULTDONE_FIELDValues.self)
        var events_resultdone_field: EVENTS_RESULTDONE_FIELD
    }

    /// Calibration is complete
    @Register(bitWidth: 32)
    struct EVENTS_CALIBRATEDONE {
        /// Calibration is complete
        @ReadWrite(bits: 0..<1, as: EVENTS_CALIBRATEDONE_FIELDValues.self)
        var events_calibratedone_field: EVENTS_CALIBRATEDONE_FIELD
    }

    /// The SAADC has stopped
    @Register(bitWidth: 32)
    struct EVENTS_STOPPED {
        /// The SAADC has stopped
        @ReadWrite(bits: 0..<1, as: EVENTS_STOPPED_FIELDValues.self)
        var events_stopped_field: EVENTS_STOPPED_FIELD
    }

    /// Enable or disable interrupt
    @Register(bitWidth: 32)
    struct INTEN {
        /// Enable or disable interrupt for event STARTED
        @ReadWrite(bits: 0..<1, as: STARTEDValues.self)
        var started: STARTED

        /// Enable or disable interrupt for event END
        @ReadWrite(bits: 1..<2, as: ENDValues.self)
        var end: END

        /// Enable or disable interrupt for event DONE
        @ReadWrite(bits: 2..<3, as: DONEValues.self)
        var done: DONE

        /// Enable or disable interrupt for event RESULTDONE
        @ReadWrite(bits: 3..<4, as: RESULTDONEValues.self)
        var resultdone: RESULTDONE

        /// Enable or disable interrupt for event CALIBRATEDONE
        @ReadWrite(bits: 4..<5, as: CALIBRATEDONEValues.self)
        var calibratedone: CALIBRATEDONE

        /// Enable or disable interrupt for event STOPPED
        @ReadWrite(bits: 5..<6, as: STOPPEDValues.self)
        var stopped: STOPPED

        /// Enable or disable interrupt for event CH0LIMITH
        @ReadWrite(bits: 6..<7, as: CH0LIMITHValues.self)
        var ch0limith: CH0LIMITH

        /// Enable or disable interrupt for event CH0LIMITL
        @ReadWrite(bits: 7..<8, as: CH0LIMITLValues.self)
        var ch0limitl: CH0LIMITL

        /// Enable or disable interrupt for event CH1LIMITH
        @ReadWrite(bits: 8..<9, as: CH1LIMITHValues.self)
        var ch1limith: CH1LIMITH

        /// Enable or disable interrupt for event CH1LIMITL
        @ReadWrite(bits: 9..<10, as: CH1LIMITLValues.self)
        var ch1limitl: CH1LIMITL

        /// Enable or disable interrupt for event CH2LIMITH
        @ReadWrite(bits: 10..<11, as: CH2LIMITHValues.self)
        var ch2limith: CH2LIMITH

        /// Enable or disable interrupt for event CH2LIMITL
        @ReadWrite(bits: 11..<12, as: CH2LIMITLValues.self)
        var ch2limitl: CH2LIMITL

        /// Enable or disable interrupt for event CH3LIMITH
        @ReadWrite(bits: 12..<13, as: CH3LIMITHValues.self)
        var ch3limith: CH3LIMITH

        /// Enable or disable interrupt for event CH3LIMITL
        @ReadWrite(bits: 13..<14, as: CH3LIMITLValues.self)
        var ch3limitl: CH3LIMITL

        /// Enable or disable interrupt for event CH4LIMITH
        @ReadWrite(bits: 14..<15, as: CH4LIMITHValues.self)
        var ch4limith: CH4LIMITH

        /// Enable or disable interrupt for event CH4LIMITL
        @ReadWrite(bits: 15..<16, as: CH4LIMITLValues.self)
        var ch4limitl: CH4LIMITL

        /// Enable or disable interrupt for event CH5LIMITH
        @ReadWrite(bits: 16..<17, as: CH5LIMITHValues.self)
        var ch5limith: CH5LIMITH

        /// Enable or disable interrupt for event CH5LIMITL
        @ReadWrite(bits: 17..<18, as: CH5LIMITLValues.self)
        var ch5limitl: CH5LIMITL

        /// Enable or disable interrupt for event CH6LIMITH
        @ReadWrite(bits: 18..<19, as: CH6LIMITHValues.self)
        var ch6limith: CH6LIMITH

        /// Enable or disable interrupt for event CH6LIMITL
        @ReadWrite(bits: 19..<20, as: CH6LIMITLValues.self)
        var ch6limitl: CH6LIMITL

        /// Enable or disable interrupt for event CH7LIMITH
        @ReadWrite(bits: 20..<21, as: CH7LIMITHValues.self)
        var ch7limith: CH7LIMITH

        /// Enable or disable interrupt for event CH7LIMITL
        @ReadWrite(bits: 21..<22, as: CH7LIMITLValues.self)
        var ch7limitl: CH7LIMITL
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event STARTED
        @ReadWrite(bits: 0..<1)
        var started: STARTED

        /// Write '1' to enable interrupt for event END
        @ReadWrite(bits: 1..<2)
        var end: END

        /// Write '1' to enable interrupt for event DONE
        @ReadWrite(bits: 2..<3)
        var done: DONE

        /// Write '1' to enable interrupt for event RESULTDONE
        @ReadWrite(bits: 3..<4)
        var resultdone: RESULTDONE

        /// Write '1' to enable interrupt for event CALIBRATEDONE
        @ReadWrite(bits: 4..<5)
        var calibratedone: CALIBRATEDONE

        /// Write '1' to enable interrupt for event STOPPED
        @ReadWrite(bits: 5..<6)
        var stopped: STOPPED

        /// Write '1' to enable interrupt for event CH0LIMITH
        @ReadWrite(bits: 6..<7)
        var ch0limith: CH0LIMITH

        /// Write '1' to enable interrupt for event CH0LIMITL
        @ReadWrite(bits: 7..<8)
        var ch0limitl: CH0LIMITL

        /// Write '1' to enable interrupt for event CH1LIMITH
        @ReadWrite(bits: 8..<9)
        var ch1limith: CH1LIMITH

        /// Write '1' to enable interrupt for event CH1LIMITL
        @ReadWrite(bits: 9..<10)
        var ch1limitl: CH1LIMITL

        /// Write '1' to enable interrupt for event CH2LIMITH
        @ReadWrite(bits: 10..<11)
        var ch2limith: CH2LIMITH

        /// Write '1' to enable interrupt for event CH2LIMITL
        @ReadWrite(bits: 11..<12)
        var ch2limitl: CH2LIMITL

        /// Write '1' to enable interrupt for event CH3LIMITH
        @ReadWrite(bits: 12..<13)
        var ch3limith: CH3LIMITH

        /// Write '1' to enable interrupt for event CH3LIMITL
        @ReadWrite(bits: 13..<14)
        var ch3limitl: CH3LIMITL

        /// Write '1' to enable interrupt for event CH4LIMITH
        @ReadWrite(bits: 14..<15)
        var ch4limith: CH4LIMITH

        /// Write '1' to enable interrupt for event CH4LIMITL
        @ReadWrite(bits: 15..<16)
        var ch4limitl: CH4LIMITL

        /// Write '1' to enable interrupt for event CH5LIMITH
        @ReadWrite(bits: 16..<17)
        var ch5limith: CH5LIMITH

        /// Write '1' to enable interrupt for event CH5LIMITL
        @ReadWrite(bits: 17..<18)
        var ch5limitl: CH5LIMITL

        /// Write '1' to enable interrupt for event CH6LIMITH
        @ReadWrite(bits: 18..<19)
        var ch6limith: CH6LIMITH

        /// Write '1' to enable interrupt for event CH6LIMITL
        @ReadWrite(bits: 19..<20)
        var ch6limitl: CH6LIMITL

        /// Write '1' to enable interrupt for event CH7LIMITH
        @ReadWrite(bits: 20..<21)
        var ch7limith: CH7LIMITH

        /// Write '1' to enable interrupt for event CH7LIMITL
        @ReadWrite(bits: 21..<22)
        var ch7limitl: CH7LIMITL
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event STARTED
        @ReadWrite(bits: 0..<1)
        var started: STARTED

        /// Write '1' to disable interrupt for event END
        @ReadWrite(bits: 1..<2)
        var end: END

        /// Write '1' to disable interrupt for event DONE
        @ReadWrite(bits: 2..<3)
        var done: DONE

        /// Write '1' to disable interrupt for event RESULTDONE
        @ReadWrite(bits: 3..<4)
        var resultdone: RESULTDONE

        /// Write '1' to disable interrupt for event CALIBRATEDONE
        @ReadWrite(bits: 4..<5)
        var calibratedone: CALIBRATEDONE

        /// Write '1' to disable interrupt for event STOPPED
        @ReadWrite(bits: 5..<6)
        var stopped: STOPPED

        /// Write '1' to disable interrupt for event CH0LIMITH
        @ReadWrite(bits: 6..<7)
        var ch0limith: CH0LIMITH

        /// Write '1' to disable interrupt for event CH0LIMITL
        @ReadWrite(bits: 7..<8)
        var ch0limitl: CH0LIMITL

        /// Write '1' to disable interrupt for event CH1LIMITH
        @ReadWrite(bits: 8..<9)
        var ch1limith: CH1LIMITH

        /// Write '1' to disable interrupt for event CH1LIMITL
        @ReadWrite(bits: 9..<10)
        var ch1limitl: CH1LIMITL

        /// Write '1' to disable interrupt for event CH2LIMITH
        @ReadWrite(bits: 10..<11)
        var ch2limith: CH2LIMITH

        /// Write '1' to disable interrupt for event CH2LIMITL
        @ReadWrite(bits: 11..<12)
        var ch2limitl: CH2LIMITL

        /// Write '1' to disable interrupt for event CH3LIMITH
        @ReadWrite(bits: 12..<13)
        var ch3limith: CH3LIMITH

        /// Write '1' to disable interrupt for event CH3LIMITL
        @ReadWrite(bits: 13..<14)
        var ch3limitl: CH3LIMITL

        /// Write '1' to disable interrupt for event CH4LIMITH
        @ReadWrite(bits: 14..<15)
        var ch4limith: CH4LIMITH

        /// Write '1' to disable interrupt for event CH4LIMITL
        @ReadWrite(bits: 15..<16)
        var ch4limitl: CH4LIMITL

        /// Write '1' to disable interrupt for event CH5LIMITH
        @ReadWrite(bits: 16..<17)
        var ch5limith: CH5LIMITH

        /// Write '1' to disable interrupt for event CH5LIMITL
        @ReadWrite(bits: 17..<18)
        var ch5limitl: CH5LIMITL

        /// Write '1' to disable interrupt for event CH6LIMITH
        @ReadWrite(bits: 18..<19)
        var ch6limith: CH6LIMITH

        /// Write '1' to disable interrupt for event CH6LIMITL
        @ReadWrite(bits: 19..<20)
        var ch6limitl: CH6LIMITL

        /// Write '1' to disable interrupt for event CH7LIMITH
        @ReadWrite(bits: 20..<21)
        var ch7limith: CH7LIMITH

        /// Write '1' to disable interrupt for event CH7LIMITL
        @ReadWrite(bits: 21..<22)
        var ch7limitl: CH7LIMITL
    }

    /// Status
    @Register(bitWidth: 32)
    struct STATUS {
        /// Status
        @ReadOnly(bits: 0..<1, as: STATUS_FIELDValues.self)
        var status_field: STATUS_FIELD
    }

    /// Enable or disable SAADC
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable or disable SAADC
        @ReadWrite(bits: 0..<1, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// Resolution configuration
    @Register(bitWidth: 32)
    struct RESOLUTION {
        /// Set the resolution
        @ReadWrite(bits: 0..<3, as: VALValues.self)
        var val: VAL
    }

    /// Oversampling configuration. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used.
    @Register(bitWidth: 32)
    struct OVERSAMPLE {
        /// Oversample control
        @ReadWrite(bits: 0..<4, as: OVERSAMPLE_FIELDValues.self)
        var oversample_field: OVERSAMPLE_FIELD
    }

    /// Controls normal or continuous sample rate
    @Register(bitWidth: 32)
    struct SAMPLERATE {
        /// Capture and compare value. Sample rate is 16 MHz/CC
        @ReadWrite(bits: 0..<11)
        var cc: CC

        /// Select mode for sample rate control
        @ReadWrite(bits: 12..<13, as: MODEValues.self)
        var mode: MODE
    }

    /// Peripheral events.
    @RegisterBlock
    struct EVENTS_CH {
        /// Description cluster: Last result is equal or above CH[n].LIMIT.HIGH
        @RegisterBlock(offset: 0x0)
        var limith: Register<LIMITH>

        /// Description cluster: Last result is equal or below CH[n].LIMIT.LOW
        @RegisterBlock(offset: 0x4)
        var limitl: Register<LIMITL>
    }

    /// Unspecified
    @RegisterBlock
    struct CH {
        /// Description cluster: Input positive pin selection for CH[n]
        @RegisterBlock(offset: 0x0)
        var pselp: Register<PSELP>

        /// Description cluster: Input negative pin selection for CH[n]
        @RegisterBlock(offset: 0x4)
        var pseln: Register<PSELN>

        /// Description cluster: Input configuration for CH[n]
        @RegisterBlock(offset: 0x8)
        var config: Register<CONFIG>

        /// Description cluster: High/low limits for event monitoring of a channel
        @RegisterBlock(offset: 0xc)
        var limit: Register<LIMIT>
    }

    /// RESULT EasyDMA channel
    @RegisterBlock
    struct RESULT {
        /// Data pointer
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>

        /// Maximum number of 16-bit samples to be written to output RAM buffer
        @RegisterBlock(offset: 0x4)
        var maxcnt: Register<MAXCNT>

        /// Number of 16-bit samples written to output RAM buffer since the previous START task
        @RegisterBlock(offset: 0x8)
        var amount: Register<AMOUNT>
    }
}

extension SAADC.EVENTS_CH {
    /// Description cluster: Last result is equal or above CH[n].LIMIT.HIGH
    @Register(bitWidth: 32)
    struct LIMITH {
        /// Last result is equal or above CH[n].LIMIT.HIGH
        @ReadWrite(bits: 0..<1, as: LIMITH_FIELDValues.self)
        var limith_field: LIMITH_FIELD
    }

    /// Description cluster: Last result is equal or below CH[n].LIMIT.LOW
    @Register(bitWidth: 32)
    struct LIMITL {
        /// Last result is equal or below CH[n].LIMIT.LOW
        @ReadWrite(bits: 0..<1, as: LIMITL_FIELDValues.self)
        var limitl_field: LIMITL_FIELD
    }
}

extension SAADC.CH {
    /// Description cluster: Input positive pin selection for CH[n]
    @Register(bitWidth: 32)
    struct PSELP {
        /// Analog positive input channel
        @ReadWrite(bits: 0..<5, as: PSELP_FIELDValues.self)
        var pselp_field: PSELP_FIELD
    }

    /// Description cluster: Input negative pin selection for CH[n]
    @Register(bitWidth: 32)
    struct PSELN {
        /// Analog negative input, enables differential channel
        @ReadWrite(bits: 0..<5, as: PSELN_FIELDValues.self)
        var pseln_field: PSELN_FIELD
    }

    /// Description cluster: Input configuration for CH[n]
    @Register(bitWidth: 32)
    struct CONFIG {
        /// Positive channel resistor control
        @ReadWrite(bits: 0..<2, as: RESPValues.self)
        var resp: RESP

        /// Negative channel resistor control
        @ReadWrite(bits: 4..<6, as: RESNValues.self)
        var resn: RESN

        /// Gain control
        @ReadWrite(bits: 8..<11, as: GAINValues.self)
        var gain: GAIN

        /// Reference control
        @ReadWrite(bits: 12..<13, as: REFSELValues.self)
        var refsel: REFSEL

        /// Acquisition time, the time the SAADC uses to sample the input voltage
        @ReadWrite(bits: 16..<19, as: TACQValues.self)
        var tacq: TACQ

        /// Enable differential mode
        @ReadWrite(bits: 20..<21, as: MODEValues.self)
        var mode: MODE

        /// Enable burst mode
        @ReadWrite(bits: 24..<25, as: BURSTValues.self)
        var burst: BURST
    }

    /// Description cluster: High/low limits for event monitoring of a channel
    @Register(bitWidth: 32)
    struct LIMIT {
        /// Low level limit
        @ReadWrite(bits: 0..<16)
        var low: LOW

        /// High level limit
        @ReadWrite(bits: 16..<32)
        var high: HIGH
    }
}

extension SAADC.RESULT {
    /// Data pointer
    @Register(bitWidth: 32)
    struct PTR {
        /// Data pointer
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }

    /// Maximum number of 16-bit samples to be written to output RAM buffer
    @Register(bitWidth: 32)
    struct MAXCNT {
        /// Maximum number of 16-bit samples to be written to output RAM buffer
        @ReadWrite(bits: 0..<15)
        var maxcnt_field: MAXCNT_FIELD
    }

    /// Number of 16-bit samples written to output RAM buffer since the previous START task
    @Register(bitWidth: 32)
    struct AMOUNT {
        /// Number of 16-bit samples written to output RAM buffer since the previous START task. This register can be read after an END or STOPPED event.
        @ReadOnly(bits: 0..<15)
        var amount_field: AMOUNT_FIELD
    }
}

extension SAADC.TASKS_START {
    struct TASKS_START_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.TASKS_SAMPLE {
    struct TASKS_SAMPLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.TASKS_CALIBRATEOFFSET {
    struct TASKS_CALIBRATEOFFSET_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.EVENTS_STARTED {
    struct EVENTS_STARTED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.EVENTS_END {
    struct EVENTS_END_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.EVENTS_DONE {
    struct EVENTS_DONE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.EVENTS_RESULTDONE {
    struct EVENTS_RESULTDONE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.EVENTS_CALIBRATEDONE {
    struct EVENTS_CALIBRATEDONE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.EVENTS_STOPPED {
    struct EVENTS_STOPPED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct STARTEDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct ENDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct DONEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct RESULTDONEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CALIBRATEDONEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct STOPPEDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH0LIMITHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH0LIMITLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH1LIMITHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH1LIMITLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH2LIMITHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH2LIMITLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH3LIMITHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH3LIMITLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH4LIMITHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH4LIMITLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH5LIMITHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH5LIMITLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH6LIMITHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH6LIMITLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH7LIMITHValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.INTEN {
    struct CH7LIMITLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.STATUS {
    struct STATUS_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// SAADC is ready. No on-going conversions.
        static let Ready = Self(rawValue: 0x0)

        /// SAADC is busy. Conversion in progress.
        static let Busy = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable SAADC
        static let Disabled = Self(rawValue: 0x0)

        /// Enable SAADC
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.RESOLUTION {
    struct VALValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// 8 bits
        static let _8bit = Self(rawValue: 0x0)

        /// 10 bits
        static let _10bit = Self(rawValue: 0x1)

        /// 12 bits
        static let _12bit = Self(rawValue: 0x2)

        /// 14 bits
        static let _14bit = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.OVERSAMPLE {
    struct OVERSAMPLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// Bypass oversampling
        static let Bypass = Self(rawValue: 0x0)

        /// Oversample 2x
        static let Over2x = Self(rawValue: 0x1)

        /// Oversample 4x
        static let Over4x = Self(rawValue: 0x2)

        /// Oversample 8x
        static let Over8x = Self(rawValue: 0x3)

        /// Oversample 16x
        static let Over16x = Self(rawValue: 0x4)

        /// Oversample 32x
        static let Over32x = Self(rawValue: 0x5)

        /// Oversample 64x
        static let Over64x = Self(rawValue: 0x6)

        /// Oversample 128x
        static let Over128x = Self(rawValue: 0x7)

        /// Oversample 256x
        static let Over256x = Self(rawValue: 0x8)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.SAMPLERATE {
    struct MODEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Rate is controlled from SAMPLE task
        static let Task = Self(rawValue: 0x0)

        /// Rate is controlled from local timer (use CC to control the rate)
        static let Timers = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.EVENTS_CH.LIMITH {
    struct LIMITH_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.EVENTS_CH.LIMITL {
    struct LIMITL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.PSELP {
    struct PSELP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 5

        /// Not connected
        static let NC = Self(rawValue: 0x0)

        /// AIN0
        static let AnalogInput0 = Self(rawValue: 0x1)

        /// AIN1
        static let AnalogInput1 = Self(rawValue: 0x2)

        /// AIN2
        static let AnalogInput2 = Self(rawValue: 0x3)

        /// AIN3
        static let AnalogInput3 = Self(rawValue: 0x4)

        /// AIN4
        static let AnalogInput4 = Self(rawValue: 0x5)

        /// AIN5
        static let AnalogInput5 = Self(rawValue: 0x6)

        /// AIN6
        static let AnalogInput6 = Self(rawValue: 0x7)

        /// AIN7
        static let AnalogInput7 = Self(rawValue: 0x8)

        /// VDD
        static let VDD = Self(rawValue: 0x9)

        /// VDDH/5
        static let VDDHDIV5 = Self(rawValue: 0xd)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.PSELN {
    struct PSELN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 5

        /// Not connected
        static let NC = Self(rawValue: 0x0)

        /// AIN0
        static let AnalogInput0 = Self(rawValue: 0x1)

        /// AIN1
        static let AnalogInput1 = Self(rawValue: 0x2)

        /// AIN2
        static let AnalogInput2 = Self(rawValue: 0x3)

        /// AIN3
        static let AnalogInput3 = Self(rawValue: 0x4)

        /// AIN4
        static let AnalogInput4 = Self(rawValue: 0x5)

        /// AIN5
        static let AnalogInput5 = Self(rawValue: 0x6)

        /// AIN6
        static let AnalogInput6 = Self(rawValue: 0x7)

        /// AIN7
        static let AnalogInput7 = Self(rawValue: 0x8)

        /// VDD
        static let VDD = Self(rawValue: 0x9)

        /// VDDH/5
        static let VDDHDIV5 = Self(rawValue: 0xd)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.CONFIG {
    struct RESPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Bypass resistor ladder
        static let Bypass = Self(rawValue: 0x0)

        /// Pull-down to GND
        static let Pulldown = Self(rawValue: 0x1)

        /// Pull-up to VDD
        static let Pullup = Self(rawValue: 0x2)

        /// Set input at VDD/2
        static let VDD1_2 = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.CONFIG {
    struct RESNValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Bypass resistor ladder
        static let Bypass = Self(rawValue: 0x0)

        /// Pull-down to GND
        static let Pulldown = Self(rawValue: 0x1)

        /// Pull-up to VDD
        static let Pullup = Self(rawValue: 0x2)

        /// Set input at VDD/2
        static let VDD1_2 = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.CONFIG {
    struct GAINValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// 1/6
        static let Gain1_6 = Self(rawValue: 0x0)

        /// 1/5
        static let Gain1_5 = Self(rawValue: 0x1)

        /// 1/4
        static let Gain1_4 = Self(rawValue: 0x2)

        /// 1/3
        static let Gain1_3 = Self(rawValue: 0x3)

        /// 1/2
        static let Gain1_2 = Self(rawValue: 0x4)

        /// 1
        static let Gain1 = Self(rawValue: 0x5)

        /// 2
        static let Gain2 = Self(rawValue: 0x6)

        /// 4
        static let Gain4 = Self(rawValue: 0x7)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.CONFIG {
    struct REFSELValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Internal reference (0.6 V)
        static let Internal = Self(rawValue: 0x0)

        /// VDD/4 as reference
        static let VDD1_4 = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.CONFIG {
    struct TACQValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// 3 us
        static let _3us = Self(rawValue: 0x0)

        /// 5 us
        static let _5us = Self(rawValue: 0x1)

        /// 10 us
        static let _10us = Self(rawValue: 0x2)

        /// 15 us
        static let _15us = Self(rawValue: 0x3)

        /// 20 us
        static let _20us = Self(rawValue: 0x4)

        /// 40 us
        static let _40us = Self(rawValue: 0x5)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.CONFIG {
    struct MODEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Single-ended, PSELN will be ignored, negative input to SAADC shorted to GND
        static let SE = Self(rawValue: 0x0)

        /// Differential
        static let Diff = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension SAADC.CH.CONFIG {
    struct BURSTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Burst mode is disabled (normal operation)
        static let Disabled = Self(rawValue: 0x0)

        /// Burst mode is enabled. SAADC takes 2^OVERSAMPLE number of samples as fast as it can, and sends the average to Data RAM.
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
