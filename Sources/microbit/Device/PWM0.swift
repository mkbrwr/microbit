// Generated by svd2swift.

import MMIO

/// Pulse width modulation unit 0
@RegisterBlock
struct PWM0 {
    /// Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    @RegisterBlock(offset: 0x4)
    var tasks_stop: Register<TASKS_STOP>

    /// Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    @RegisterBlock(offset: 0x8, stride: 0x4, count: 2)
    var tasks_seqstart: RegisterArray<TASKS_SEQSTART>

    /// Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    @RegisterBlock(offset: 0x10)
    var tasks_nextstep: Register<TASKS_NEXTSTEP>

    /// Response to STOP task, emitted when PWM pulses are no longer generated
    @RegisterBlock(offset: 0x104)
    var events_stopped: Register<EVENTS_STOPPED>

    /// Description collection: First PWM period started on sequence n
    @RegisterBlock(offset: 0x108, stride: 0x4, count: 2)
    var events_seqstarted: RegisterArray<EVENTS_SEQSTARTED>

    /// Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    @RegisterBlock(offset: 0x110, stride: 0x4, count: 2)
    var events_seqend: RegisterArray<EVENTS_SEQEND>

    /// Emitted at the end of each PWM period
    @RegisterBlock(offset: 0x118)
    var events_pwmperiodend: Register<EVENTS_PWMPERIODEND>

    /// Concatenated sequences have been played the amount of times defined in LOOP.CNT
    @RegisterBlock(offset: 0x11c)
    var events_loopsdone: Register<EVENTS_LOOPSDONE>

    /// Shortcuts between local events and tasks
    @RegisterBlock(offset: 0x200)
    var shorts: Register<SHORTS>

    /// Enable or disable interrupt
    @RegisterBlock(offset: 0x300)
    var inten: Register<INTEN>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// PWM module enable register
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// Selects operating mode of the wave counter
    @RegisterBlock(offset: 0x504)
    var mode: Register<MODE>

    /// Value up to which the pulse generator counter counts
    @RegisterBlock(offset: 0x508)
    var countertop: Register<COUNTERTOP>

    /// Configuration for PWM_CLK
    @RegisterBlock(offset: 0x50c)
    var prescaler: Register<PRESCALER>

    /// Configuration of the decoder
    @RegisterBlock(offset: 0x510)
    var decoder: Register<DECODER>

    /// Number of playbacks of a loop
    @RegisterBlock(offset: 0x514)
    var loop: Register<LOOP>

    /// Unspecified
    @RegisterBlock(offset: 0x520, stride: 0x20, count: 2)
    var seq: RegisterArray<SEQ>

    /// Unspecified
    @RegisterBlock(offset: 0x560)
    var psel: PSEL
}

extension PWM0 {
    /// Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    @Register(bitWidth: 32)
    struct TASKS_SEQSTART {
        /// Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
        @WriteOnly(bits: 0..<1, as: TASKS_SEQSTART_FIELDValues.self)
        var tasks_seqstart_field: TASKS_SEQSTART_FIELD
    }

    /// Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    @Register(bitWidth: 32)
    struct TASKS_NEXTSTEP {
        /// Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
        @WriteOnly(bits: 0..<1, as: TASKS_NEXTSTEP_FIELDValues.self)
        var tasks_nextstep_field: TASKS_NEXTSTEP_FIELD
    }

    /// Response to STOP task, emitted when PWM pulses are no longer generated
    @Register(bitWidth: 32)
    struct EVENTS_STOPPED {
        /// Response to STOP task, emitted when PWM pulses are no longer generated
        @ReadWrite(bits: 0..<1, as: EVENTS_STOPPED_FIELDValues.self)
        var events_stopped_field: EVENTS_STOPPED_FIELD
    }

    /// Description collection: First PWM period started on sequence n
    @Register(bitWidth: 32)
    struct EVENTS_SEQSTARTED {
        /// First PWM period started on sequence n
        @ReadWrite(bits: 0..<1, as: EVENTS_SEQSTARTED_FIELDValues.self)
        var events_seqstarted_field: EVENTS_SEQSTARTED_FIELD
    }

    /// Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    @Register(bitWidth: 32)
    struct EVENTS_SEQEND {
        /// Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
        @ReadWrite(bits: 0..<1, as: EVENTS_SEQEND_FIELDValues.self)
        var events_seqend_field: EVENTS_SEQEND_FIELD
    }

    /// Emitted at the end of each PWM period
    @Register(bitWidth: 32)
    struct EVENTS_PWMPERIODEND {
        /// Emitted at the end of each PWM period
        @ReadWrite(bits: 0..<1, as: EVENTS_PWMPERIODEND_FIELDValues.self)
        var events_pwmperiodend_field: EVENTS_PWMPERIODEND_FIELD
    }

    /// Concatenated sequences have been played the amount of times defined in LOOP.CNT
    @Register(bitWidth: 32)
    struct EVENTS_LOOPSDONE {
        /// Concatenated sequences have been played the amount of times defined in LOOP.CNT
        @ReadWrite(bits: 0..<1, as: EVENTS_LOOPSDONE_FIELDValues.self)
        var events_loopsdone_field: EVENTS_LOOPSDONE_FIELD
    }

    /// Shortcuts between local events and tasks
    @Register(bitWidth: 32)
    struct SHORTS {
        /// Shortcut between event SEQEND[0] and task STOP
        @ReadWrite(bits: 0..<1, as: SEQEND0_STOPValues.self)
        var seqend0_stop: SEQEND0_STOP

        /// Shortcut between event SEQEND[1] and task STOP
        @ReadWrite(bits: 1..<2, as: SEQEND1_STOPValues.self)
        var seqend1_stop: SEQEND1_STOP

        /// Shortcut between event LOOPSDONE and task SEQSTART[0]
        @ReadWrite(bits: 2..<3, as: LOOPSDONE_SEQSTART0Values.self)
        var loopsdone_seqstart0: LOOPSDONE_SEQSTART0

        /// Shortcut between event LOOPSDONE and task SEQSTART[1]
        @ReadWrite(bits: 3..<4, as: LOOPSDONE_SEQSTART1Values.self)
        var loopsdone_seqstart1: LOOPSDONE_SEQSTART1

        /// Shortcut between event LOOPSDONE and task STOP
        @ReadWrite(bits: 4..<5, as: LOOPSDONE_STOPValues.self)
        var loopsdone_stop: LOOPSDONE_STOP
    }

    /// Enable or disable interrupt
    @Register(bitWidth: 32)
    struct INTEN {
        /// Enable or disable interrupt for event STOPPED
        @ReadWrite(bits: 1..<2, as: STOPPEDValues.self)
        var stopped: STOPPED

        /// Enable or disable interrupt for event SEQSTARTED[0]
        @ReadWrite(bits: 2..<3, as: SEQSTARTED0Values.self)
        var seqstarted0: SEQSTARTED0

        /// Enable or disable interrupt for event SEQSTARTED[1]
        @ReadWrite(bits: 3..<4, as: SEQSTARTED1Values.self)
        var seqstarted1: SEQSTARTED1

        /// Enable or disable interrupt for event SEQEND[0]
        @ReadWrite(bits: 4..<5, as: SEQEND0Values.self)
        var seqend0: SEQEND0

        /// Enable or disable interrupt for event SEQEND[1]
        @ReadWrite(bits: 5..<6, as: SEQEND1Values.self)
        var seqend1: SEQEND1

        /// Enable or disable interrupt for event PWMPERIODEND
        @ReadWrite(bits: 6..<7, as: PWMPERIODENDValues.self)
        var pwmperiodend: PWMPERIODEND

        /// Enable or disable interrupt for event LOOPSDONE
        @ReadWrite(bits: 7..<8, as: LOOPSDONEValues.self)
        var loopsdone: LOOPSDONE
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event STOPPED
        @ReadWrite(bits: 1..<2)
        var stopped: STOPPED

        /// Write '1' to enable interrupt for event SEQSTARTED[0]
        @ReadWrite(bits: 2..<3)
        var seqstarted0: SEQSTARTED0

        /// Write '1' to enable interrupt for event SEQSTARTED[1]
        @ReadWrite(bits: 3..<4)
        var seqstarted1: SEQSTARTED1

        /// Write '1' to enable interrupt for event SEQEND[0]
        @ReadWrite(bits: 4..<5)
        var seqend0: SEQEND0

        /// Write '1' to enable interrupt for event SEQEND[1]
        @ReadWrite(bits: 5..<6)
        var seqend1: SEQEND1

        /// Write '1' to enable interrupt for event PWMPERIODEND
        @ReadWrite(bits: 6..<7)
        var pwmperiodend: PWMPERIODEND

        /// Write '1' to enable interrupt for event LOOPSDONE
        @ReadWrite(bits: 7..<8)
        var loopsdone: LOOPSDONE
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event STOPPED
        @ReadWrite(bits: 1..<2)
        var stopped: STOPPED

        /// Write '1' to disable interrupt for event SEQSTARTED[0]
        @ReadWrite(bits: 2..<3)
        var seqstarted0: SEQSTARTED0

        /// Write '1' to disable interrupt for event SEQSTARTED[1]
        @ReadWrite(bits: 3..<4)
        var seqstarted1: SEQSTARTED1

        /// Write '1' to disable interrupt for event SEQEND[0]
        @ReadWrite(bits: 4..<5)
        var seqend0: SEQEND0

        /// Write '1' to disable interrupt for event SEQEND[1]
        @ReadWrite(bits: 5..<6)
        var seqend1: SEQEND1

        /// Write '1' to disable interrupt for event PWMPERIODEND
        @ReadWrite(bits: 6..<7)
        var pwmperiodend: PWMPERIODEND

        /// Write '1' to disable interrupt for event LOOPSDONE
        @ReadWrite(bits: 7..<8)
        var loopsdone: LOOPSDONE
    }

    /// PWM module enable register
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable or disable PWM module
        @ReadWrite(bits: 0..<1, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// Selects operating mode of the wave counter
    @Register(bitWidth: 32)
    struct MODE {
        /// Selects up mode or up-and-down mode for the counter
        @ReadWrite(bits: 0..<1, as: UPDOWNValues.self)
        var updown: UPDOWN
    }

    /// Value up to which the pulse generator counter counts
    @Register(bitWidth: 32)
    struct COUNTERTOP {
        /// Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used.
        @ReadWrite(bits: 0..<15)
        var countertop_field: COUNTERTOP_FIELD
    }

    /// Configuration for PWM_CLK
    @Register(bitWidth: 32)
    struct PRESCALER {
        /// Prescaler of PWM_CLK
        @ReadWrite(bits: 0..<3, as: PRESCALER_FIELDValues.self)
        var prescaler_field: PRESCALER_FIELD
    }

    /// Configuration of the decoder
    @Register(bitWidth: 32)
    struct DECODER {
        /// How a sequence is read from RAM and spread to the compare register
        @ReadWrite(bits: 0..<2, as: LOADValues.self)
        var load: LOAD

        /// Selects source for advancing the active sequence
        @ReadWrite(bits: 8..<9, as: MODEValues.self)
        var mode: MODE
    }

    /// Number of playbacks of a loop
    @Register(bitWidth: 32)
    struct LOOP {
        /// Number of playbacks of pattern cycles
        @ReadWrite(bits: 0..<16, as: CNTValues.self)
        var cnt: CNT
    }

    /// Unspecified
    @RegisterBlock
    struct SEQ {
        /// Description cluster: Beginning address in RAM of this sequence
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>

        /// Description cluster: Number of values (duty cycles) in this sequence
        @RegisterBlock(offset: 0x4)
        var cnt: Register<CNT>

        /// Description cluster: Number of additional PWM periods between samples loaded into compare register
        @RegisterBlock(offset: 0x8)
        var refresh: Register<REFRESH>

        /// Description cluster: Time added after the sequence
        @RegisterBlock(offset: 0xc)
        var enddelay: Register<ENDDELAY>
    }

    /// Unspecified
    @RegisterBlock
    struct PSEL {
        /// Description collection: Output pin select for PWM channel n
        @RegisterBlock(offset: 0x0, stride: 0x4, count: 4)
        var out: RegisterArray<OUT>
    }
}

extension PWM0.SEQ {
    /// Description cluster: Beginning address in RAM of this sequence
    @Register(bitWidth: 32)
    struct PTR {
        /// Beginning address in RAM of this sequence
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }

    /// Description cluster: Number of values (duty cycles) in this sequence
    @Register(bitWidth: 32)
    struct CNT {
        /// Number of values (duty cycles) in this sequence
        @ReadWrite(bits: 0..<15, as: CNT_FIELDValues.self)
        var cnt_field: CNT_FIELD
    }

    /// Description cluster: Number of additional PWM periods between samples loaded into compare register
    @Register(bitWidth: 32)
    struct REFRESH {
        /// Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)
        @ReadWrite(bits: 0..<24, as: CNTValues.self)
        var cnt: CNT
    }

    /// Description cluster: Time added after the sequence
    @Register(bitWidth: 32)
    struct ENDDELAY {
        /// Time added after the sequence in PWM periods
        @ReadWrite(bits: 0..<24)
        var cnt: CNT
    }
}

extension PWM0.PSEL {
    /// Description collection: Output pin select for PWM channel n
    @Register(bitWidth: 32)
    struct OUT {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }
}

extension PWM0.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.TASKS_SEQSTART {
    struct TASKS_SEQSTART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.TASKS_NEXTSTEP {
    struct TASKS_NEXTSTEP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.EVENTS_STOPPED {
    struct EVENTS_STOPPED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.EVENTS_SEQSTARTED {
    struct EVENTS_SEQSTARTED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.EVENTS_SEQEND {
    struct EVENTS_SEQEND_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.EVENTS_PWMPERIODEND {
    struct EVENTS_PWMPERIODEND_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.EVENTS_LOOPSDONE {
    struct EVENTS_LOOPSDONE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.SHORTS {
    struct SEQEND0_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.SHORTS {
    struct SEQEND1_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.SHORTS {
    struct LOOPSDONE_SEQSTART0Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.SHORTS {
    struct LOOPSDONE_SEQSTART1Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.SHORTS {
    struct LOOPSDONE_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.INTEN {
    struct STOPPEDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.INTEN {
    struct SEQSTARTED0Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.INTEN {
    struct SEQSTARTED1Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.INTEN {
    struct SEQEND0Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.INTEN {
    struct SEQEND1Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.INTEN {
    struct PWMPERIODENDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.INTEN {
    struct LOOPSDONEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.MODE {
    struct UPDOWNValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Up counter, edge-aligned PWM duty cycle
        static let Up = Self(rawValue: 0x0)

        /// Up and down counter, center-aligned PWM duty cycle
        static let UpAndDown = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.PRESCALER {
    struct PRESCALER_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// Divide by 1 (16 MHz)
        static let DIV_1 = Self(rawValue: 0x0)

        /// Divide by 2 (8 MHz)
        static let DIV_2 = Self(rawValue: 0x1)

        /// Divide by 4 (4 MHz)
        static let DIV_4 = Self(rawValue: 0x2)

        /// Divide by 8 (2 MHz)
        static let DIV_8 = Self(rawValue: 0x3)

        /// Divide by 16 (1 MHz)
        static let DIV_16 = Self(rawValue: 0x4)

        /// Divide by 32 (500 kHz)
        static let DIV_32 = Self(rawValue: 0x5)

        /// Divide by 64 (250 kHz)
        static let DIV_64 = Self(rawValue: 0x6)

        /// Divide by 128 (125 kHz)
        static let DIV_128 = Self(rawValue: 0x7)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.DECODER {
    struct LOADValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// 1st half word (16-bit) used in all PWM channels 0..3
        static let Common = Self(rawValue: 0x0)

        /// 1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3
        static let Grouped = Self(rawValue: 0x1)

        /// 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3
        static let Individual = Self(rawValue: 0x2)

        /// 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP
        static let WaveForm = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.DECODER {
    struct MODEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// SEQ[n].REFRESH is used to determine loading internal compare registers
        static let RefreshCount = Self(rawValue: 0x0)

        /// NEXTSTEP task causes a new value to be loaded to internal compare registers
        static let NextStep = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.LOOP {
    struct CNTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 16

        /// Looping disabled (stop at the end of the sequence)
        static let Disabled = Self(rawValue: 0x0)

        var rawValue: UInt16

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.SEQ.CNT {
    struct CNT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 15

        /// Sequence is disabled, and shall not be started as it is empty
        static let Disabled = Self(rawValue: 0x0)

        var rawValue: UInt16

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.SEQ.REFRESH {
    struct CNTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 24

        /// Update every PWM period
        static let Continuous = Self(rawValue: 0x0)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension PWM0.PSEL.OUT {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
