// Generated by svd2swift.

import MMIO

/// 2.4 GHz radio
@RegisterBlock
struct RADIO {
    /// Enable RADIO in TX mode
    @RegisterBlock(offset: 0x0)
    var tasks_txen: Register<TASKS_TXEN>

    /// Enable RADIO in RX mode
    @RegisterBlock(offset: 0x4)
    var tasks_rxen: Register<TASKS_RXEN>

    /// Start RADIO
    @RegisterBlock(offset: 0x8)
    var tasks_start: Register<TASKS_START>

    /// Stop RADIO
    @RegisterBlock(offset: 0xc)
    var tasks_stop: Register<TASKS_STOP>

    /// Disable RADIO
    @RegisterBlock(offset: 0x10)
    var tasks_disable: Register<TASKS_DISABLE>

    /// Start the RSSI and take one single sample of the receive signal strength
    @RegisterBlock(offset: 0x14)
    var tasks_rssistart: Register<TASKS_RSSISTART>

    /// Stop the RSSI measurement
    @RegisterBlock(offset: 0x18)
    var tasks_rssistop: Register<TASKS_RSSISTOP>

    /// Start the bit counter
    @RegisterBlock(offset: 0x1c)
    var tasks_bcstart: Register<TASKS_BCSTART>

    /// Stop the bit counter
    @RegisterBlock(offset: 0x20)
    var tasks_bcstop: Register<TASKS_BCSTOP>

    /// Start the energy detect measurement used in IEEE 802.15.4 mode
    @RegisterBlock(offset: 0x24)
    var tasks_edstart: Register<TASKS_EDSTART>

    /// Stop the energy detect measurement
    @RegisterBlock(offset: 0x28)
    var tasks_edstop: Register<TASKS_EDSTOP>

    /// Start the clear channel assessment used in IEEE 802.15.4 mode
    @RegisterBlock(offset: 0x2c)
    var tasks_ccastart: Register<TASKS_CCASTART>

    /// Stop the clear channel assessment
    @RegisterBlock(offset: 0x30)
    var tasks_ccastop: Register<TASKS_CCASTOP>

    /// RADIO has ramped up and is ready to be started
    @RegisterBlock(offset: 0x100)
    var events_ready: Register<EVENTS_READY>

    /// Address sent or received
    @RegisterBlock(offset: 0x104)
    var events_address: Register<EVENTS_ADDRESS>

    /// Packet payload sent or received
    @RegisterBlock(offset: 0x108)
    var events_payload: Register<EVENTS_PAYLOAD>

    /// Packet sent or received
    @RegisterBlock(offset: 0x10c)
    var events_end: Register<EVENTS_END>

    /// RADIO has been disabled
    @RegisterBlock(offset: 0x110)
    var events_disabled: Register<EVENTS_DISABLED>

    /// A device address match occurred on the last received packet
    @RegisterBlock(offset: 0x114)
    var events_devmatch: Register<EVENTS_DEVMATCH>

    /// No device address match occurred on the last received packet
    @RegisterBlock(offset: 0x118)
    var events_devmiss: Register<EVENTS_DEVMISS>

    /// Sampling of receive signal strength complete
    @RegisterBlock(offset: 0x11c)
    var events_rssiend: Register<EVENTS_RSSIEND>

    /// Bit counter reached bit count value
    @RegisterBlock(offset: 0x128)
    var events_bcmatch: Register<EVENTS_BCMATCH>

    /// Packet received with CRC ok
    @RegisterBlock(offset: 0x130)
    var events_crcok: Register<EVENTS_CRCOK>

    /// Packet received with CRC error
    @RegisterBlock(offset: 0x134)
    var events_crcerror: Register<EVENTS_CRCERROR>

    /// IEEE 802.15.4 length field received
    @RegisterBlock(offset: 0x138)
    var events_framestart: Register<EVENTS_FRAMESTART>

    /// Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register.
    @RegisterBlock(offset: 0x13c)
    var events_edend: Register<EVENTS_EDEND>

    /// The sampling of energy detection has stopped
    @RegisterBlock(offset: 0x140)
    var events_edstopped: Register<EVENTS_EDSTOPPED>

    /// Wireless medium in idle - clear to send
    @RegisterBlock(offset: 0x144)
    var events_ccaidle: Register<EVENTS_CCAIDLE>

    /// Wireless medium busy - do not send
    @RegisterBlock(offset: 0x148)
    var events_ccabusy: Register<EVENTS_CCABUSY>

    /// The CCA has stopped
    @RegisterBlock(offset: 0x14c)
    var events_ccastopped: Register<EVENTS_CCASTOPPED>

    /// Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
    @RegisterBlock(offset: 0x150)
    var events_rateboost: Register<EVENTS_RATEBOOST>

    /// RADIO has ramped up and is ready to be started TX path
    @RegisterBlock(offset: 0x154)
    var events_txready: Register<EVENTS_TXREADY>

    /// RADIO has ramped up and is ready to be started RX path
    @RegisterBlock(offset: 0x158)
    var events_rxready: Register<EVENTS_RXREADY>

    /// MAC header match found
    @RegisterBlock(offset: 0x15c)
    var events_mhrmatch: Register<EVENTS_MHRMATCH>

    /// Preamble indicator
    @RegisterBlock(offset: 0x168)
    var events_sync: Register<EVENTS_SYNC>

    /// Generated when last bit is sent on air, or received from air
    @RegisterBlock(offset: 0x16c)
    var events_phyend: Register<EVENTS_PHYEND>

    /// CTE is present (early warning right after receiving CTEInfo byte)
    @RegisterBlock(offset: 0x170)
    var events_ctepresent: Register<EVENTS_CTEPRESENT>

    /// Shortcuts between local events and tasks
    @RegisterBlock(offset: 0x200)
    var shorts: Register<SHORTS>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// CRC status
    @RegisterBlock(offset: 0x400)
    var crcstatus: Register<CRCSTATUS>

    /// Received address
    @RegisterBlock(offset: 0x408)
    var rxmatch: Register<RXMATCH>

    /// CRC field of previously received packet
    @RegisterBlock(offset: 0x40c)
    var rxcrc: Register<RXCRC>

    /// Device address match index
    @RegisterBlock(offset: 0x410)
    var dai: Register<DAI>

    /// Payload status
    @RegisterBlock(offset: 0x414)
    var pdustat: Register<PDUSTAT>

    /// CTEInfo parsed from received packet
    @RegisterBlock(offset: 0x44c)
    var ctestatus: Register<CTESTATUS>

    /// DFE status information
    @RegisterBlock(offset: 0x458)
    var dfestatus: Register<DFESTATUS>

    /// Packet pointer
    @RegisterBlock(offset: 0x504)
    var packetptr: Register<PACKETPTR>

    /// Frequency
    @RegisterBlock(offset: 0x508)
    var frequency: Register<FREQUENCY>

    /// Output power
    @RegisterBlock(offset: 0x50c)
    var txpower: Register<TXPOWER>

    /// Data rate and modulation
    @RegisterBlock(offset: 0x510)
    var mode: Register<MODE>

    /// Packet configuration register 0
    @RegisterBlock(offset: 0x514)
    var pcnf0: Register<PCNF0>

    /// Packet configuration register 1
    @RegisterBlock(offset: 0x518)
    var pcnf1: Register<PCNF1>

    /// Base address 0
    @RegisterBlock(offset: 0x51c)
    var base0: Register<BASE0>

    /// Base address 1
    @RegisterBlock(offset: 0x520)
    var base1: Register<BASE1>

    /// Prefixes bytes for logical addresses 0-3
    @RegisterBlock(offset: 0x524)
    var prefix0: Register<PREFIX0>

    /// Prefixes bytes for logical addresses 4-7
    @RegisterBlock(offset: 0x528)
    var prefix1: Register<PREFIX1>

    /// Transmit address select
    @RegisterBlock(offset: 0x52c)
    var txaddress: Register<TXADDRESS>

    /// Receive address select
    @RegisterBlock(offset: 0x530)
    var rxaddresses: Register<RXADDRESSES>

    /// CRC configuration
    @RegisterBlock(offset: 0x534)
    var crccnf: Register<CRCCNF>

    /// CRC polynomial
    @RegisterBlock(offset: 0x538)
    var crcpoly: Register<CRCPOLY>

    /// CRC initial value
    @RegisterBlock(offset: 0x53c)
    var crcinit: Register<CRCINIT>

    /// Interframe spacing in us
    @RegisterBlock(offset: 0x544)
    var tifs: Register<TIFS>

    /// RSSI sample
    @RegisterBlock(offset: 0x548)
    var rssisample: Register<RSSISAMPLE>

    /// Current radio state
    @RegisterBlock(offset: 0x550)
    var state: Register<STATE>

    /// Data whitening initial value
    @RegisterBlock(offset: 0x554)
    var datawhiteiv: Register<DATAWHITEIV>

    /// Bit counter compare
    @RegisterBlock(offset: 0x560)
    var bcc: Register<BCC>

    /// Description collection: Device address base segment n
    @RegisterBlock(offset: 0x600, stride: 0x4, count: 8)
    var dab: RegisterArray<DAB>

    /// Description collection: Device address prefix n
    @RegisterBlock(offset: 0x620, stride: 0x4, count: 8)
    var dap: RegisterArray<DAP>

    /// Device address match configuration
    @RegisterBlock(offset: 0x640)
    var dacnf: Register<DACNF>

    /// Search pattern configuration
    @RegisterBlock(offset: 0x644)
    var mhrmatchconf: Register<MHRMATCHCONF>

    /// Pattern mask
    @RegisterBlock(offset: 0x648)
    var mhrmatchmas: Register<MHRMATCHMAS>

    /// Radio mode configuration register 0
    @RegisterBlock(offset: 0x650)
    var modecnf0: Register<MODECNF0>

    /// IEEE 802.15.4 start of frame delimiter
    @RegisterBlock(offset: 0x660)
    var sfd: Register<SFD>

    /// IEEE 802.15.4 energy detect loop count
    @RegisterBlock(offset: 0x664)
    var edcnt: Register<EDCNT>

    /// IEEE 802.15.4 energy detect level
    @RegisterBlock(offset: 0x668)
    var edsample: Register<EDSAMPLE>

    /// IEEE 802.15.4 clear channel assessment control
    @RegisterBlock(offset: 0x66c)
    var ccactrl: Register<CCACTRL>

    /// Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)
    @RegisterBlock(offset: 0x900)
    var dfemode: Register<DFEMODE>

    /// Configuration for CTE inline mode
    @RegisterBlock(offset: 0x904)
    var cteinlineconf: Register<CTEINLINECONF>

    /// Various configuration for Direction finding
    @RegisterBlock(offset: 0x910)
    var dfectrl1: Register<DFECTRL1>

    /// Start offset for Direction finding
    @RegisterBlock(offset: 0x914)
    var dfectrl2: Register<DFECTRL2>

    /// GPIO patterns to be used for each antenna
    @RegisterBlock(offset: 0x928)
    var switchpattern: Register<SWITCHPATTERN>

    /// Clear the GPIO pattern array for antenna control
    @RegisterBlock(offset: 0x92c)
    var clearpattern: Register<CLEARPATTERN>

    /// Peripheral power control
    @RegisterBlock(offset: 0xffc)
    var power: Register<POWER>

    /// Unspecified
    @RegisterBlock(offset: 0x930)
    var psel: PSEL

    /// DFE packet EasyDMA channel
    @RegisterBlock(offset: 0x950)
    var dfepacket: DFEPACKET
}

extension RADIO {
    /// Enable RADIO in TX mode
    @Register(bitWidth: 32)
    struct TASKS_TXEN {
        /// Enable RADIO in TX mode
        @WriteOnly(bits: 0..<1, as: TASKS_TXEN_FIELDValues.self)
        var tasks_txen_field: TASKS_TXEN_FIELD
    }

    /// Enable RADIO in RX mode
    @Register(bitWidth: 32)
    struct TASKS_RXEN {
        /// Enable RADIO in RX mode
        @WriteOnly(bits: 0..<1, as: TASKS_RXEN_FIELDValues.self)
        var tasks_rxen_field: TASKS_RXEN_FIELD
    }

    /// Start RADIO
    @Register(bitWidth: 32)
    struct TASKS_START {
        /// Start RADIO
        @WriteOnly(bits: 0..<1, as: TASKS_START_FIELDValues.self)
        var tasks_start_field: TASKS_START_FIELD
    }

    /// Stop RADIO
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stop RADIO
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// Disable RADIO
    @Register(bitWidth: 32)
    struct TASKS_DISABLE {
        /// Disable RADIO
        @WriteOnly(bits: 0..<1, as: TASKS_DISABLE_FIELDValues.self)
        var tasks_disable_field: TASKS_DISABLE_FIELD
    }

    /// Start the RSSI and take one single sample of the receive signal strength
    @Register(bitWidth: 32)
    struct TASKS_RSSISTART {
        /// Start the RSSI and take one single sample of the receive signal strength
        @WriteOnly(bits: 0..<1, as: TASKS_RSSISTART_FIELDValues.self)
        var tasks_rssistart_field: TASKS_RSSISTART_FIELD
    }

    /// Stop the RSSI measurement
    @Register(bitWidth: 32)
    struct TASKS_RSSISTOP {
        /// Stop the RSSI measurement
        @WriteOnly(bits: 0..<1, as: TASKS_RSSISTOP_FIELDValues.self)
        var tasks_rssistop_field: TASKS_RSSISTOP_FIELD
    }

    /// Start the bit counter
    @Register(bitWidth: 32)
    struct TASKS_BCSTART {
        /// Start the bit counter
        @WriteOnly(bits: 0..<1, as: TASKS_BCSTART_FIELDValues.self)
        var tasks_bcstart_field: TASKS_BCSTART_FIELD
    }

    /// Stop the bit counter
    @Register(bitWidth: 32)
    struct TASKS_BCSTOP {
        /// Stop the bit counter
        @WriteOnly(bits: 0..<1, as: TASKS_BCSTOP_FIELDValues.self)
        var tasks_bcstop_field: TASKS_BCSTOP_FIELD
    }

    /// Start the energy detect measurement used in IEEE 802.15.4 mode
    @Register(bitWidth: 32)
    struct TASKS_EDSTART {
        /// Start the energy detect measurement used in IEEE 802.15.4 mode
        @WriteOnly(bits: 0..<1, as: TASKS_EDSTART_FIELDValues.self)
        var tasks_edstart_field: TASKS_EDSTART_FIELD
    }

    /// Stop the energy detect measurement
    @Register(bitWidth: 32)
    struct TASKS_EDSTOP {
        /// Stop the energy detect measurement
        @WriteOnly(bits: 0..<1, as: TASKS_EDSTOP_FIELDValues.self)
        var tasks_edstop_field: TASKS_EDSTOP_FIELD
    }

    /// Start the clear channel assessment used in IEEE 802.15.4 mode
    @Register(bitWidth: 32)
    struct TASKS_CCASTART {
        /// Start the clear channel assessment used in IEEE 802.15.4 mode
        @WriteOnly(bits: 0..<1, as: TASKS_CCASTART_FIELDValues.self)
        var tasks_ccastart_field: TASKS_CCASTART_FIELD
    }

    /// Stop the clear channel assessment
    @Register(bitWidth: 32)
    struct TASKS_CCASTOP {
        /// Stop the clear channel assessment
        @WriteOnly(bits: 0..<1, as: TASKS_CCASTOP_FIELDValues.self)
        var tasks_ccastop_field: TASKS_CCASTOP_FIELD
    }

    /// RADIO has ramped up and is ready to be started
    @Register(bitWidth: 32)
    struct EVENTS_READY {
        /// RADIO has ramped up and is ready to be started
        @ReadWrite(bits: 0..<1, as: EVENTS_READY_FIELDValues.self)
        var events_ready_field: EVENTS_READY_FIELD
    }

    /// Address sent or received
    @Register(bitWidth: 32)
    struct EVENTS_ADDRESS {
        /// Address sent or received
        @ReadWrite(bits: 0..<1, as: EVENTS_ADDRESS_FIELDValues.self)
        var events_address_field: EVENTS_ADDRESS_FIELD
    }

    /// Packet payload sent or received
    @Register(bitWidth: 32)
    struct EVENTS_PAYLOAD {
        /// Packet payload sent or received
        @ReadWrite(bits: 0..<1, as: EVENTS_PAYLOAD_FIELDValues.self)
        var events_payload_field: EVENTS_PAYLOAD_FIELD
    }

    /// Packet sent or received
    @Register(bitWidth: 32)
    struct EVENTS_END {
        /// Packet sent or received
        @ReadWrite(bits: 0..<1, as: EVENTS_END_FIELDValues.self)
        var events_end_field: EVENTS_END_FIELD
    }

    /// RADIO has been disabled
    @Register(bitWidth: 32)
    struct EVENTS_DISABLED {
        /// RADIO has been disabled
        @ReadWrite(bits: 0..<1, as: EVENTS_DISABLED_FIELDValues.self)
        var events_disabled_field: EVENTS_DISABLED_FIELD
    }

    /// A device address match occurred on the last received packet
    @Register(bitWidth: 32)
    struct EVENTS_DEVMATCH {
        /// A device address match occurred on the last received packet
        @ReadWrite(bits: 0..<1, as: EVENTS_DEVMATCH_FIELDValues.self)
        var events_devmatch_field: EVENTS_DEVMATCH_FIELD
    }

    /// No device address match occurred on the last received packet
    @Register(bitWidth: 32)
    struct EVENTS_DEVMISS {
        /// No device address match occurred on the last received packet
        @ReadWrite(bits: 0..<1, as: EVENTS_DEVMISS_FIELDValues.self)
        var events_devmiss_field: EVENTS_DEVMISS_FIELD
    }

    /// Sampling of receive signal strength complete
    @Register(bitWidth: 32)
    struct EVENTS_RSSIEND {
        /// Sampling of receive signal strength complete
        @ReadWrite(bits: 0..<1, as: EVENTS_RSSIEND_FIELDValues.self)
        var events_rssiend_field: EVENTS_RSSIEND_FIELD
    }

    /// Bit counter reached bit count value
    @Register(bitWidth: 32)
    struct EVENTS_BCMATCH {
        /// Bit counter reached bit count value
        @ReadWrite(bits: 0..<1, as: EVENTS_BCMATCH_FIELDValues.self)
        var events_bcmatch_field: EVENTS_BCMATCH_FIELD
    }

    /// Packet received with CRC ok
    @Register(bitWidth: 32)
    struct EVENTS_CRCOK {
        /// Packet received with CRC ok
        @ReadWrite(bits: 0..<1, as: EVENTS_CRCOK_FIELDValues.self)
        var events_crcok_field: EVENTS_CRCOK_FIELD
    }

    /// Packet received with CRC error
    @Register(bitWidth: 32)
    struct EVENTS_CRCERROR {
        /// Packet received with CRC error
        @ReadWrite(bits: 0..<1, as: EVENTS_CRCERROR_FIELDValues.self)
        var events_crcerror_field: EVENTS_CRCERROR_FIELD
    }

    /// IEEE 802.15.4 length field received
    @Register(bitWidth: 32)
    struct EVENTS_FRAMESTART {
        /// IEEE 802.15.4 length field received
        @ReadWrite(bits: 0..<1, as: EVENTS_FRAMESTART_FIELDValues.self)
        var events_framestart_field: EVENTS_FRAMESTART_FIELD
    }

    /// Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register.
    @Register(bitWidth: 32)
    struct EVENTS_EDEND {
        /// Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register.
        @ReadWrite(bits: 0..<1, as: EVENTS_EDEND_FIELDValues.self)
        var events_edend_field: EVENTS_EDEND_FIELD
    }

    /// The sampling of energy detection has stopped
    @Register(bitWidth: 32)
    struct EVENTS_EDSTOPPED {
        /// The sampling of energy detection has stopped
        @ReadWrite(bits: 0..<1, as: EVENTS_EDSTOPPED_FIELDValues.self)
        var events_edstopped_field: EVENTS_EDSTOPPED_FIELD
    }

    /// Wireless medium in idle - clear to send
    @Register(bitWidth: 32)
    struct EVENTS_CCAIDLE {
        /// Wireless medium in idle - clear to send
        @ReadWrite(bits: 0..<1, as: EVENTS_CCAIDLE_FIELDValues.self)
        var events_ccaidle_field: EVENTS_CCAIDLE_FIELD
    }

    /// Wireless medium busy - do not send
    @Register(bitWidth: 32)
    struct EVENTS_CCABUSY {
        /// Wireless medium busy - do not send
        @ReadWrite(bits: 0..<1, as: EVENTS_CCABUSY_FIELDValues.self)
        var events_ccabusy_field: EVENTS_CCABUSY_FIELD
    }

    /// The CCA has stopped
    @Register(bitWidth: 32)
    struct EVENTS_CCASTOPPED {
        /// The CCA has stopped
        @ReadWrite(bits: 0..<1, as: EVENTS_CCASTOPPED_FIELDValues.self)
        var events_ccastopped_field: EVENTS_CCASTOPPED_FIELD
    }

    /// Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
    @Register(bitWidth: 32)
    struct EVENTS_RATEBOOST {
        /// Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
        @ReadWrite(bits: 0..<1, as: EVENTS_RATEBOOST_FIELDValues.self)
        var events_rateboost_field: EVENTS_RATEBOOST_FIELD
    }

    /// RADIO has ramped up and is ready to be started TX path
    @Register(bitWidth: 32)
    struct EVENTS_TXREADY {
        /// RADIO has ramped up and is ready to be started TX path
        @ReadWrite(bits: 0..<1, as: EVENTS_TXREADY_FIELDValues.self)
        var events_txready_field: EVENTS_TXREADY_FIELD
    }

    /// RADIO has ramped up and is ready to be started RX path
    @Register(bitWidth: 32)
    struct EVENTS_RXREADY {
        /// RADIO has ramped up and is ready to be started RX path
        @ReadWrite(bits: 0..<1, as: EVENTS_RXREADY_FIELDValues.self)
        var events_rxready_field: EVENTS_RXREADY_FIELD
    }

    /// MAC header match found
    @Register(bitWidth: 32)
    struct EVENTS_MHRMATCH {
        /// MAC header match found
        @ReadWrite(bits: 0..<1, as: EVENTS_MHRMATCH_FIELDValues.self)
        var events_mhrmatch_field: EVENTS_MHRMATCH_FIELD
    }

    /// Preamble indicator
    @Register(bitWidth: 32)
    struct EVENTS_SYNC {
        /// Preamble indicator
        @ReadWrite(bits: 0..<1, as: EVENTS_SYNC_FIELDValues.self)
        var events_sync_field: EVENTS_SYNC_FIELD
    }

    /// Generated when last bit is sent on air, or received from air
    @Register(bitWidth: 32)
    struct EVENTS_PHYEND {
        /// Generated when last bit is sent on air, or received from air
        @ReadWrite(bits: 0..<1, as: EVENTS_PHYEND_FIELDValues.self)
        var events_phyend_field: EVENTS_PHYEND_FIELD
    }

    /// CTE is present (early warning right after receiving CTEInfo byte)
    @Register(bitWidth: 32)
    struct EVENTS_CTEPRESENT {
        /// CTE is present (early warning right after receiving CTEInfo byte)
        @ReadWrite(bits: 0..<1, as: EVENTS_CTEPRESENT_FIELDValues.self)
        var events_ctepresent_field: EVENTS_CTEPRESENT_FIELD
    }

    /// Shortcuts between local events and tasks
    @Register(bitWidth: 32)
    struct SHORTS {
        /// Shortcut between event READY and task START
        @ReadWrite(bits: 0..<1, as: READY_STARTValues.self)
        var ready_start: READY_START

        /// Shortcut between event END and task DISABLE
        @ReadWrite(bits: 1..<2, as: END_DISABLEValues.self)
        var end_disable: END_DISABLE

        /// Shortcut between event DISABLED and task TXEN
        @ReadWrite(bits: 2..<3, as: DISABLED_TXENValues.self)
        var disabled_txen: DISABLED_TXEN

        /// Shortcut between event DISABLED and task RXEN
        @ReadWrite(bits: 3..<4, as: DISABLED_RXENValues.self)
        var disabled_rxen: DISABLED_RXEN

        /// Shortcut between event ADDRESS and task RSSISTART
        @ReadWrite(bits: 4..<5, as: ADDRESS_RSSISTARTValues.self)
        var address_rssistart: ADDRESS_RSSISTART

        /// Shortcut between event END and task START
        @ReadWrite(bits: 5..<6, as: END_STARTValues.self)
        var end_start: END_START

        /// Shortcut between event ADDRESS and task BCSTART
        @ReadWrite(bits: 6..<7, as: ADDRESS_BCSTARTValues.self)
        var address_bcstart: ADDRESS_BCSTART

        /// Shortcut between event DISABLED and task RSSISTOP
        @ReadWrite(bits: 8..<9, as: DISABLED_RSSISTOPValues.self)
        var disabled_rssistop: DISABLED_RSSISTOP

        /// Shortcut between event RXREADY and task CCASTART
        @ReadWrite(bits: 11..<12, as: RXREADY_CCASTARTValues.self)
        var rxready_ccastart: RXREADY_CCASTART

        /// Shortcut between event CCAIDLE and task TXEN
        @ReadWrite(bits: 12..<13, as: CCAIDLE_TXENValues.self)
        var ccaidle_txen: CCAIDLE_TXEN

        /// Shortcut between event CCABUSY and task DISABLE
        @ReadWrite(bits: 13..<14, as: CCABUSY_DISABLEValues.self)
        var ccabusy_disable: CCABUSY_DISABLE

        /// Shortcut between event FRAMESTART and task BCSTART
        @ReadWrite(bits: 14..<15, as: FRAMESTART_BCSTARTValues.self)
        var framestart_bcstart: FRAMESTART_BCSTART

        /// Shortcut between event READY and task EDSTART
        @ReadWrite(bits: 15..<16, as: READY_EDSTARTValues.self)
        var ready_edstart: READY_EDSTART

        /// Shortcut between event EDEND and task DISABLE
        @ReadWrite(bits: 16..<17, as: EDEND_DISABLEValues.self)
        var edend_disable: EDEND_DISABLE

        /// Shortcut between event CCAIDLE and task STOP
        @ReadWrite(bits: 17..<18, as: CCAIDLE_STOPValues.self)
        var ccaidle_stop: CCAIDLE_STOP

        /// Shortcut between event TXREADY and task START
        @ReadWrite(bits: 18..<19, as: TXREADY_STARTValues.self)
        var txready_start: TXREADY_START

        /// Shortcut between event RXREADY and task START
        @ReadWrite(bits: 19..<20, as: RXREADY_STARTValues.self)
        var rxready_start: RXREADY_START

        /// Shortcut between event PHYEND and task DISABLE
        @ReadWrite(bits: 20..<21, as: PHYEND_DISABLEValues.self)
        var phyend_disable: PHYEND_DISABLE

        /// Shortcut between event PHYEND and task START
        @ReadWrite(bits: 21..<22, as: PHYEND_STARTValues.self)
        var phyend_start: PHYEND_START
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event READY
        @ReadWrite(bits: 0..<1)
        var ready: READY

        /// Write '1' to enable interrupt for event ADDRESS
        @ReadWrite(bits: 1..<2)
        var address: ADDRESS

        /// Write '1' to enable interrupt for event PAYLOAD
        @ReadWrite(bits: 2..<3)
        var payload: PAYLOAD

        /// Write '1' to enable interrupt for event END
        @ReadWrite(bits: 3..<4)
        var end: END

        /// Write '1' to enable interrupt for event DISABLED
        @ReadWrite(bits: 4..<5)
        var disabled: DISABLED

        /// Write '1' to enable interrupt for event DEVMATCH
        @ReadWrite(bits: 5..<6)
        var devmatch: DEVMATCH

        /// Write '1' to enable interrupt for event DEVMISS
        @ReadWrite(bits: 6..<7)
        var devmiss: DEVMISS

        /// Write '1' to enable interrupt for event RSSIEND
        @ReadWrite(bits: 7..<8)
        var rssiend: RSSIEND

        /// Write '1' to enable interrupt for event BCMATCH
        @ReadWrite(bits: 10..<11)
        var bcmatch: BCMATCH

        /// Write '1' to enable interrupt for event CRCOK
        @ReadWrite(bits: 12..<13)
        var crcok: CRCOK

        /// Write '1' to enable interrupt for event CRCERROR
        @ReadWrite(bits: 13..<14)
        var crcerror: CRCERROR

        /// Write '1' to enable interrupt for event FRAMESTART
        @ReadWrite(bits: 14..<15)
        var framestart: FRAMESTART

        /// Write '1' to enable interrupt for event EDEND
        @ReadWrite(bits: 15..<16)
        var edend: EDEND

        /// Write '1' to enable interrupt for event EDSTOPPED
        @ReadWrite(bits: 16..<17)
        var edstopped: EDSTOPPED

        /// Write '1' to enable interrupt for event CCAIDLE
        @ReadWrite(bits: 17..<18)
        var ccaidle: CCAIDLE

        /// Write '1' to enable interrupt for event CCABUSY
        @ReadWrite(bits: 18..<19)
        var ccabusy: CCABUSY

        /// Write '1' to enable interrupt for event CCASTOPPED
        @ReadWrite(bits: 19..<20)
        var ccastopped: CCASTOPPED

        /// Write '1' to enable interrupt for event RATEBOOST
        @ReadWrite(bits: 20..<21)
        var rateboost: RATEBOOST

        /// Write '1' to enable interrupt for event TXREADY
        @ReadWrite(bits: 21..<22)
        var txready: TXREADY

        /// Write '1' to enable interrupt for event RXREADY
        @ReadWrite(bits: 22..<23)
        var rxready: RXREADY

        /// Write '1' to enable interrupt for event MHRMATCH
        @ReadWrite(bits: 23..<24)
        var mhrmatch: MHRMATCH

        /// Write '1' to enable interrupt for event SYNC
        @ReadWrite(bits: 26..<27)
        var sync: SYNC

        /// Write '1' to enable interrupt for event PHYEND
        @ReadWrite(bits: 27..<28)
        var phyend: PHYEND

        /// Write '1' to enable interrupt for event CTEPRESENT
        @ReadWrite(bits: 28..<29)
        var ctepresent: CTEPRESENT
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event READY
        @ReadWrite(bits: 0..<1)
        var ready: READY

        /// Write '1' to disable interrupt for event ADDRESS
        @ReadWrite(bits: 1..<2)
        var address: ADDRESS

        /// Write '1' to disable interrupt for event PAYLOAD
        @ReadWrite(bits: 2..<3)
        var payload: PAYLOAD

        /// Write '1' to disable interrupt for event END
        @ReadWrite(bits: 3..<4)
        var end: END

        /// Write '1' to disable interrupt for event DISABLED
        @ReadWrite(bits: 4..<5)
        var disabled: DISABLED

        /// Write '1' to disable interrupt for event DEVMATCH
        @ReadWrite(bits: 5..<6)
        var devmatch: DEVMATCH

        /// Write '1' to disable interrupt for event DEVMISS
        @ReadWrite(bits: 6..<7)
        var devmiss: DEVMISS

        /// Write '1' to disable interrupt for event RSSIEND
        @ReadWrite(bits: 7..<8)
        var rssiend: RSSIEND

        /// Write '1' to disable interrupt for event BCMATCH
        @ReadWrite(bits: 10..<11)
        var bcmatch: BCMATCH

        /// Write '1' to disable interrupt for event CRCOK
        @ReadWrite(bits: 12..<13)
        var crcok: CRCOK

        /// Write '1' to disable interrupt for event CRCERROR
        @ReadWrite(bits: 13..<14)
        var crcerror: CRCERROR

        /// Write '1' to disable interrupt for event FRAMESTART
        @ReadWrite(bits: 14..<15)
        var framestart: FRAMESTART

        /// Write '1' to disable interrupt for event EDEND
        @ReadWrite(bits: 15..<16)
        var edend: EDEND

        /// Write '1' to disable interrupt for event EDSTOPPED
        @ReadWrite(bits: 16..<17)
        var edstopped: EDSTOPPED

        /// Write '1' to disable interrupt for event CCAIDLE
        @ReadWrite(bits: 17..<18)
        var ccaidle: CCAIDLE

        /// Write '1' to disable interrupt for event CCABUSY
        @ReadWrite(bits: 18..<19)
        var ccabusy: CCABUSY

        /// Write '1' to disable interrupt for event CCASTOPPED
        @ReadWrite(bits: 19..<20)
        var ccastopped: CCASTOPPED

        /// Write '1' to disable interrupt for event RATEBOOST
        @ReadWrite(bits: 20..<21)
        var rateboost: RATEBOOST

        /// Write '1' to disable interrupt for event TXREADY
        @ReadWrite(bits: 21..<22)
        var txready: TXREADY

        /// Write '1' to disable interrupt for event RXREADY
        @ReadWrite(bits: 22..<23)
        var rxready: RXREADY

        /// Write '1' to disable interrupt for event MHRMATCH
        @ReadWrite(bits: 23..<24)
        var mhrmatch: MHRMATCH

        /// Write '1' to disable interrupt for event SYNC
        @ReadWrite(bits: 26..<27)
        var sync: SYNC

        /// Write '1' to disable interrupt for event PHYEND
        @ReadWrite(bits: 27..<28)
        var phyend: PHYEND

        /// Write '1' to disable interrupt for event CTEPRESENT
        @ReadWrite(bits: 28..<29)
        var ctepresent: CTEPRESENT
    }

    /// CRC status
    @Register(bitWidth: 32)
    struct CRCSTATUS {
        /// CRC status of packet received
        @ReadOnly(bits: 0..<1, as: CRCSTATUS_FIELDValues.self)
        var crcstatus_field: CRCSTATUS_FIELD
    }

    /// Received address
    @Register(bitWidth: 32)
    struct RXMATCH {
        /// Received address
        @ReadOnly(bits: 0..<3)
        var rxmatch_field: RXMATCH_FIELD
    }

    /// CRC field of previously received packet
    @Register(bitWidth: 32)
    struct RXCRC {
        /// CRC field of previously received packet
        @ReadOnly(bits: 0..<24)
        var rxcrc_field: RXCRC_FIELD
    }

    /// Device address match index
    @Register(bitWidth: 32)
    struct DAI {
        /// Device address match index
        @ReadOnly(bits: 0..<3)
        var dai_field: DAI_FIELD
    }

    /// Payload status
    @Register(bitWidth: 32)
    struct PDUSTAT {
        /// Status on payload length vs. PCNF1.MAXLEN
        @ReadOnly(bits: 0..<1, as: PDUSTAT_FIELDValues.self)
        var pdustat_field: PDUSTAT_FIELD

        /// Status on what rate packet is received with in Long Range
        @ReadOnly(bits: 1..<3, as: CISTATValues.self)
        var cistat: CISTAT
    }

    /// CTEInfo parsed from received packet
    @Register(bitWidth: 32)
    struct CTESTATUS {
        /// CTETime parsed from packet
        @ReadOnly(bits: 0..<5)
        var ctetime: CTETIME

        /// RFU parsed from packet
        @ReadOnly(bits: 5..<6)
        var rfu: RFU

        /// CTEType parsed from packet
        @ReadOnly(bits: 6..<8)
        var ctetype: CTETYPE
    }

    /// DFE status information
    @Register(bitWidth: 32)
    struct DFESTATUS {
        /// Internal state of switching state machine
        @ReadOnly(bits: 0..<3, as: SWITCHINGSTATEValues.self)
        var switchingstate: SWITCHINGSTATE

        /// Internal state of sampling state machine
        @ReadOnly(bits: 4..<5, as: SAMPLINGSTATEValues.self)
        var samplingstate: SAMPLINGSTATE
    }

    /// Packet pointer
    @Register(bitWidth: 32)
    struct PACKETPTR {
        /// Packet pointer
        @ReadWrite(bits: 0..<32)
        var packetptr_field: PACKETPTR_FIELD
    }

    /// Frequency
    @Register(bitWidth: 32)
    struct FREQUENCY {
        /// Radio channel frequency
        @ReadWrite(bits: 0..<7)
        var frequency_field: FREQUENCY_FIELD

        /// Channel map selection
        @ReadWrite(bits: 8..<9, as: MAPValues.self)
        var map: MAP
    }

    /// Output power
    @Register(bitWidth: 32)
    struct TXPOWER {
        /// RADIO output power
        @ReadWrite(bits: 0..<8, as: TXPOWER_FIELDValues.self)
        var txpower_field: TXPOWER_FIELD
    }

    /// Data rate and modulation
    @Register(bitWidth: 32)
    struct MODE {
        /// Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation.
        @ReadWrite(bits: 0..<4, as: MODE_FIELDValues.self)
        var mode_field: MODE_FIELD
    }

    /// Packet configuration register 0
    @Register(bitWidth: 32)
    struct PCNF0 {
        /// Length on air of LENGTH field in number of bits
        @ReadWrite(bits: 0..<4)
        var lflen: LFLEN

        /// Length on air of S0 field in number of bytes
        @ReadWrite(bits: 8..<9)
        var s0len: S0LEN

        /// Length on air of S1 field in number of bits
        @ReadWrite(bits: 16..<20)
        var s1len: S1LEN

        /// Include or exclude S1 field in RAM
        @ReadWrite(bits: 20..<21, as: S1INCLValues.self)
        var s1incl: S1INCL

        /// Length of code indicator - long range
        @ReadWrite(bits: 22..<24)
        var cilen: CILEN

        /// Length of preamble on air. Decision point: TASKS_START task
        @ReadWrite(bits: 24..<26, as: PLENValues.self)
        var plen: PLEN

        /// Indicates if LENGTH field contains CRC or not
        @ReadWrite(bits: 26..<27, as: CRCINCValues.self)
        var crcinc: CRCINC

        /// Length of TERM field in Long Range operation
        @ReadWrite(bits: 29..<31)
        var termlen: TERMLEN
    }

    /// Packet configuration register 1
    @Register(bitWidth: 32)
    struct PCNF1 {
        /// Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN.
        @ReadWrite(bits: 0..<8)
        var maxlen: MAXLEN

        /// Static length in number of bytes
        @ReadWrite(bits: 8..<16)
        var statlen: STATLEN

        /// Base address length in number of bytes
        @ReadWrite(bits: 16..<19)
        var balen: BALEN

        /// On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields.
        @ReadWrite(bits: 24..<25, as: ENDIANValues.self)
        var endian: ENDIAN

        /// Enable or disable packet whitening
        @ReadWrite(bits: 25..<26, as: WHITEENValues.self)
        var whiteen: WHITEEN
    }

    /// Base address 0
    @Register(bitWidth: 32)
    struct BASE0 {
        /// Base address 0
        @ReadWrite(bits: 0..<32)
        var base0_field: BASE0_FIELD
    }

    /// Base address 1
    @Register(bitWidth: 32)
    struct BASE1 {
        /// Base address 1
        @ReadWrite(bits: 0..<32)
        var base1_field: BASE1_FIELD
    }

    /// Prefixes bytes for logical addresses 0-3
    @Register(bitWidth: 32)
    struct PREFIX0 {
        /// Address prefix 0.
        @ReadWrite(bits: 0..<8)
        var ap0: AP0

        /// Address prefix 1.
        @ReadWrite(bits: 8..<16)
        var ap1: AP1

        /// Address prefix 2.
        @ReadWrite(bits: 16..<24)
        var ap2: AP2

        /// Address prefix 3.
        @ReadWrite(bits: 24..<32)
        var ap3: AP3
    }

    /// Prefixes bytes for logical addresses 4-7
    @Register(bitWidth: 32)
    struct PREFIX1 {
        /// Address prefix 4.
        @ReadWrite(bits: 0..<8)
        var ap4: AP4

        /// Address prefix 5.
        @ReadWrite(bits: 8..<16)
        var ap5: AP5

        /// Address prefix 6.
        @ReadWrite(bits: 16..<24)
        var ap6: AP6

        /// Address prefix 7.
        @ReadWrite(bits: 24..<32)
        var ap7: AP7
    }

    /// Transmit address select
    @Register(bitWidth: 32)
    struct TXADDRESS {
        /// Transmit address select
        @ReadWrite(bits: 0..<3)
        var txaddress_field: TXADDRESS_FIELD
    }

    /// Receive address select
    @Register(bitWidth: 32)
    struct RXADDRESSES {
        /// Enable or disable reception on logical address 0.
        @ReadWrite(bits: 0..<1, as: ADDR0Values.self)
        var addr0: ADDR0

        /// Enable or disable reception on logical address 1.
        @ReadWrite(bits: 1..<2, as: ADDR1Values.self)
        var addr1: ADDR1

        /// Enable or disable reception on logical address 2.
        @ReadWrite(bits: 2..<3, as: ADDR2Values.self)
        var addr2: ADDR2

        /// Enable or disable reception on logical address 3.
        @ReadWrite(bits: 3..<4, as: ADDR3Values.self)
        var addr3: ADDR3

        /// Enable or disable reception on logical address 4.
        @ReadWrite(bits: 4..<5, as: ADDR4Values.self)
        var addr4: ADDR4

        /// Enable or disable reception on logical address 5.
        @ReadWrite(bits: 5..<6, as: ADDR5Values.self)
        var addr5: ADDR5

        /// Enable or disable reception on logical address 6.
        @ReadWrite(bits: 6..<7, as: ADDR6Values.self)
        var addr6: ADDR6

        /// Enable or disable reception on logical address 7.
        @ReadWrite(bits: 7..<8, as: ADDR7Values.self)
        var addr7: ADDR7
    }

    /// CRC configuration
    @Register(bitWidth: 32)
    struct CRCCNF {
        /// CRC length in number of bytes For MODE Ble_LR125Kbit and Ble_LR500Kbit, only LEN set to 3 is supported
        @ReadWrite(bits: 0..<2, as: LENValues.self)
        var len: LEN

        /// Include or exclude packet address field out of CRC calculation.
        @ReadWrite(bits: 8..<10, as: SKIPADDRValues.self)
        var skipaddr: SKIPADDR
    }

    /// CRC polynomial
    @Register(bitWidth: 32)
    struct CRCPOLY {
        /// CRC polynomial
        @ReadWrite(bits: 0..<24)
        var crcpoly_field: CRCPOLY_FIELD
    }

    /// CRC initial value
    @Register(bitWidth: 32)
    struct CRCINIT {
        /// CRC initial value
        @ReadWrite(bits: 0..<24)
        var crcinit_field: CRCINIT_FIELD
    }

    /// Interframe spacing in us
    @Register(bitWidth: 32)
    struct TIFS {
        /// Interframe spacing in us.
        @ReadWrite(bits: 0..<10)
        var tifs_field: TIFS_FIELD
    }

    /// RSSI sample
    @Register(bitWidth: 32)
    struct RSSISAMPLE {
        /// RSSI sample.
        @ReadOnly(bits: 0..<7)
        var rssisample_field: RSSISAMPLE_FIELD
    }

    /// Current radio state
    @Register(bitWidth: 32)
    struct STATE {
        /// Current radio state
        @ReadOnly(bits: 0..<4, as: STATE_FIELDValues.self)
        var state_field: STATE_FIELD
    }

    /// Data whitening initial value
    @Register(bitWidth: 32)
    struct DATAWHITEIV {
        /// Data whitening initial value. Bit 6 is hardwired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'.
        @ReadWrite(bits: 0..<7)
        var datawhiteiv_field: DATAWHITEIV_FIELD
    }

    /// Bit counter compare
    @Register(bitWidth: 32)
    struct BCC {
        /// Bit counter compare
        @ReadWrite(bits: 0..<32)
        var bcc_field: BCC_FIELD
    }

    /// Description collection: Device address base segment n
    @Register(bitWidth: 32)
    struct DAB {
        /// Device address base segment n
        @ReadWrite(bits: 0..<32)
        var dab_field: DAB_FIELD
    }

    /// Description collection: Device address prefix n
    @Register(bitWidth: 32)
    struct DAP {
        /// Device address prefix n
        @ReadWrite(bits: 0..<16)
        var dap_field: DAP_FIELD
    }

    /// Device address match configuration
    @Register(bitWidth: 32)
    struct DACNF {
        /// Enable or disable device address matching using device address 0
        @ReadWrite(bits: 0..<1, as: ENA0Values.self)
        var ena0: ENA0

        /// Enable or disable device address matching using device address 1
        @ReadWrite(bits: 1..<2, as: ENA1Values.self)
        var ena1: ENA1

        /// Enable or disable device address matching using device address 2
        @ReadWrite(bits: 2..<3, as: ENA2Values.self)
        var ena2: ENA2

        /// Enable or disable device address matching using device address 3
        @ReadWrite(bits: 3..<4, as: ENA3Values.self)
        var ena3: ENA3

        /// Enable or disable device address matching using device address 4
        @ReadWrite(bits: 4..<5, as: ENA4Values.self)
        var ena4: ENA4

        /// Enable or disable device address matching using device address 5
        @ReadWrite(bits: 5..<6, as: ENA5Values.self)
        var ena5: ENA5

        /// Enable or disable device address matching using device address 6
        @ReadWrite(bits: 6..<7, as: ENA6Values.self)
        var ena6: ENA6

        /// Enable or disable device address matching using device address 7
        @ReadWrite(bits: 7..<8, as: ENA7Values.self)
        var ena7: ENA7

        /// TxAdd for device address 0
        @ReadWrite(bits: 8..<9)
        var txadd0: TXADD0

        /// TxAdd for device address 1
        @ReadWrite(bits: 9..<10)
        var txadd1: TXADD1

        /// TxAdd for device address 2
        @ReadWrite(bits: 10..<11)
        var txadd2: TXADD2

        /// TxAdd for device address 3
        @ReadWrite(bits: 11..<12)
        var txadd3: TXADD3

        /// TxAdd for device address 4
        @ReadWrite(bits: 12..<13)
        var txadd4: TXADD4

        /// TxAdd for device address 5
        @ReadWrite(bits: 13..<14)
        var txadd5: TXADD5

        /// TxAdd for device address 6
        @ReadWrite(bits: 14..<15)
        var txadd6: TXADD6

        /// TxAdd for device address 7
        @ReadWrite(bits: 15..<16)
        var txadd7: TXADD7
    }

    /// Search pattern configuration
    @Register(bitWidth: 32)
    struct MHRMATCHCONF {
        /// Search pattern configuration
        @ReadWrite(bits: 0..<32)
        var mhrmatchconf_field: MHRMATCHCONF_FIELD
    }

    /// Pattern mask
    @Register(bitWidth: 32)
    struct MHRMATCHMAS {
        /// Pattern mask
        @ReadWrite(bits: 0..<32)
        var mhrmatchmas_field: MHRMATCHMAS_FIELD
    }

    /// Radio mode configuration register 0
    @Register(bitWidth: 32)
    struct MODECNF0 {
        /// Radio ramp-up time
        @ReadWrite(bits: 0..<1, as: RUValues.self)
        var ru: RU

        /// Default TX value
        @ReadWrite(bits: 8..<10, as: DTXValues.self)
        var dtx: DTX
    }

    /// IEEE 802.15.4 start of frame delimiter
    @Register(bitWidth: 32)
    struct SFD {
        /// IEEE 802.15.4 start of frame delimiter
        @ReadWrite(bits: 0..<8)
        var sfd_field: SFD_FIELD
    }

    /// IEEE 802.15.4 energy detect loop count
    @Register(bitWidth: 32)
    struct EDCNT {
        /// IEEE 802.15.4 energy detect loop count
        @ReadWrite(bits: 0..<21)
        var edcnt_field: EDCNT_FIELD
    }

    /// IEEE 802.15.4 energy detect level
    @Register(bitWidth: 32)
    struct EDSAMPLE {
        /// IEEE 802.15.4 energy detect level
        @ReadOnly(bits: 0..<8)
        var edlvl: EDLVL
    }

    /// IEEE 802.15.4 clear channel assessment control
    @Register(bitWidth: 32)
    struct CCACTRL {
        /// CCA mode of operation
        @ReadWrite(bits: 0..<3, as: CCAMODEValues.self)
        var ccamode: CCAMODE

        /// CCA energy busy threshold. Used in all the CCA modes except CarrierMode.
        @ReadWrite(bits: 8..<16)
        var ccaedthres: CCAEDTHRES

        /// CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode.
        @ReadWrite(bits: 16..<24)
        var ccacorrthres: CCACORRTHRES

        /// Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled.
        @ReadWrite(bits: 24..<32)
        var ccacorrcnt: CCACORRCNT
    }

    /// Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)
    @Register(bitWidth: 32)
    struct DFEMODE {
        /// Direction finding operation mode
        @ReadWrite(bits: 0..<2, as: DFEOPMODEValues.self)
        var dfeopmode: DFEOPMODE
    }

    /// Configuration for CTE inline mode
    @Register(bitWidth: 32)
    struct CTEINLINECONF {
        /// Enable parsing of CTEInfo from received packet in BLE modes
        @ReadWrite(bits: 0..<1, as: CTEINLINECTRLENValues.self)
        var cteinlinectrlen: CTEINLINECTRLEN

        /// CTEInfo is S1 byte or not
        @ReadWrite(bits: 3..<4, as: CTEINFOINS1Values.self)
        var cteinfoins1: CTEINFOINS1

        /// Sampling/switching if CRC is not OK
        @ReadWrite(bits: 4..<5, as: CTEERRORHANDLINGValues.self)
        var cteerrorhandling: CTEERRORHANDLING

        /// Max range of CTETime
        @ReadWrite(bits: 6..<8, as: CTETIMEVALIDRANGEValues.self)
        var ctetimevalidrange: CTETIMEVALIDRANGE

        /// Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set.
        @ReadWrite(bits: 10..<13, as: CTEINLINERXMODE1USValues.self)
        var cteinlinerxmode1us: CTEINLINERXMODE1US

        /// Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set.
        @ReadWrite(bits: 13..<16, as: CTEINLINERXMODE2USValues.self)
        var cteinlinerxmode2us: CTEINLINERXMODE2US

        /// S0 bit pattern to match
        @ReadWrite(bits: 16..<24)
        var s0conf: S0CONF

        /// S0 bit mask to set which bit to match
        @ReadWrite(bits: 24..<32)
        var s0mask: S0MASK
    }

    /// Various configuration for Direction finding
    @Register(bitWidth: 32)
    struct DFECTRL1 {
        /// Length of the AoA/AoD procedure in number of 8 us units
        @ReadWrite(bits: 0..<6)
        var numberof8us: NUMBEROF8US

        /// Add CTE extension and do antenna switching/sampling in this extension
        @ReadWrite(bits: 7..<8, as: DFEINEXTENSIONValues.self)
        var dfeinextension: DFEINEXTENSION

        /// Interval between every time the antenna is changed in the SWITCHING state
        @ReadWrite(bits: 8..<11, as: TSWITCHSPACINGValues.self)
        var tswitchspacing: TSWITCHSPACING

        /// Interval between samples in the REFERENCE period
        @ReadWrite(bits: 12..<15, as: TSAMPLESPACINGREFValues.self)
        var tsamplespacingref: TSAMPLESPACINGREF

        /// Whether to sample I/Q or magnitude/phase
        @ReadWrite(bits: 15..<16, as: SAMPLETYPEValues.self)
        var sampletype: SAMPLETYPE

        /// Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0
        @ReadWrite(bits: 16..<19, as: TSAMPLESPACINGValues.self)
        var tsamplespacing: TSAMPLESPACING

        /// Repeat each individual antenna pattern N times sequentially, i.e. P0, P0, P1, P1, P2, P2, P3, P3, etc.
        @ReadWrite(bits: 20..<24, as: REPEATPATTERNValues.self)
        var repeatpattern: REPEATPATTERN

        /// Gain will be lowered by the specified number of gain steps at the start of CTE
        @ReadWrite(bits: 24..<28)
        var agcbackoffgain: AGCBACKOFFGAIN
    }

    /// Start offset for Direction finding
    @Register(bitWidth: 32)
    struct DFECTRL2 {
        /// Signed value offset after the end of the CRC before starting switching in number of 16M cycles
        @ReadWrite(bits: 0..<13)
        var tswitchoffset: TSWITCHOFFSET

        /// Signed value offset before starting sampling in number of 16M cycles relative to the beginning of the REFERENCE state - 12 us after switching start
        @ReadWrite(bits: 16..<28)
        var tsampleoffset: TSAMPLEOFFSET
    }

    /// GPIO patterns to be used for each antenna
    @Register(bitWidth: 32)
    struct SWITCHPATTERN {
        /// Fill array of GPIO patterns for antenna control.
        @ReadWrite(bits: 0..<8)
        var switchpattern_field: SWITCHPATTERN_FIELD
    }

    /// Clear the GPIO pattern array for antenna control
    @Register(bitWidth: 32)
    struct CLEARPATTERN {
        /// Clears GPIO pattern array for antenna control
        @ReadWrite(bits: 0..<1, as: CLEARPATTERN_FIELDValues.self)
        var clearpattern_field: CLEARPATTERN_FIELD
    }

    /// Peripheral power control
    @Register(bitWidth: 32)
    struct POWER {
        /// Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again.
        @ReadWrite(bits: 0..<1, as: POWER_FIELDValues.self)
        var power_field: POWER_FIELD
    }

    /// Unspecified
    @RegisterBlock
    struct PSEL {
        /// Description collection: Pin select for DFE pin n
        @RegisterBlock(offset: 0x0, stride: 0x4, count: 8)
        var dfegpio: RegisterArray<DFEGPIO>
    }

    /// DFE packet EasyDMA channel
    @RegisterBlock
    struct DFEPACKET {
        /// Data pointer
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>

        /// Maximum number of buffer words to transfer
        @RegisterBlock(offset: 0x4)
        var maxcnt: Register<MAXCNT>

        /// Number of samples transferred in the last transaction
        @RegisterBlock(offset: 0x8)
        var amount: Register<AMOUNT>
    }
}

extension RADIO.PSEL {
    /// Description collection: Pin select for DFE pin n
    @Register(bitWidth: 32)
    struct DFEGPIO {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }
}

extension RADIO.DFEPACKET {
    /// Data pointer
    @Register(bitWidth: 32)
    struct PTR {
        /// Data pointer
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }

    /// Maximum number of buffer words to transfer
    @Register(bitWidth: 32)
    struct MAXCNT {
        /// Maximum number of buffer words to transfer
        @ReadWrite(bits: 0..<14)
        var maxcnt_field: MAXCNT_FIELD
    }

    /// Number of samples transferred in the last transaction
    @Register(bitWidth: 32)
    struct AMOUNT {
        /// Number of samples transferred in the last transaction
        @ReadOnly(bits: 0..<16)
        var amount_field: AMOUNT_FIELD
    }
}

extension RADIO.TASKS_TXEN {
    struct TASKS_TXEN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_RXEN {
    struct TASKS_RXEN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_START {
    struct TASKS_START_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_DISABLE {
    struct TASKS_DISABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_RSSISTART {
    struct TASKS_RSSISTART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_RSSISTOP {
    struct TASKS_RSSISTOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_BCSTART {
    struct TASKS_BCSTART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_BCSTOP {
    struct TASKS_BCSTOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_EDSTART {
    struct TASKS_EDSTART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_EDSTOP {
    struct TASKS_EDSTOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_CCASTART {
    struct TASKS_CCASTART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TASKS_CCASTOP {
    struct TASKS_CCASTOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_READY {
    struct EVENTS_READY_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_ADDRESS {
    struct EVENTS_ADDRESS_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_PAYLOAD {
    struct EVENTS_PAYLOAD_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_END {
    struct EVENTS_END_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_DISABLED {
    struct EVENTS_DISABLED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_DEVMATCH {
    struct EVENTS_DEVMATCH_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_DEVMISS {
    struct EVENTS_DEVMISS_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_RSSIEND {
    struct EVENTS_RSSIEND_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_BCMATCH {
    struct EVENTS_BCMATCH_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_CRCOK {
    struct EVENTS_CRCOK_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_CRCERROR {
    struct EVENTS_CRCERROR_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_FRAMESTART {
    struct EVENTS_FRAMESTART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_EDEND {
    struct EVENTS_EDEND_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_EDSTOPPED {
    struct EVENTS_EDSTOPPED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_CCAIDLE {
    struct EVENTS_CCAIDLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_CCABUSY {
    struct EVENTS_CCABUSY_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_CCASTOPPED {
    struct EVENTS_CCASTOPPED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_RATEBOOST {
    struct EVENTS_RATEBOOST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_TXREADY {
    struct EVENTS_TXREADY_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_RXREADY {
    struct EVENTS_RXREADY_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_MHRMATCH {
    struct EVENTS_MHRMATCH_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_SYNC {
    struct EVENTS_SYNC_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_PHYEND {
    struct EVENTS_PHYEND_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.EVENTS_CTEPRESENT {
    struct EVENTS_CTEPRESENT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct READY_STARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct END_DISABLEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct DISABLED_TXENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct DISABLED_RXENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct ADDRESS_RSSISTARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct END_STARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct ADDRESS_BCSTARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct DISABLED_RSSISTOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct RXREADY_CCASTARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct CCAIDLE_TXENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct CCABUSY_DISABLEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct FRAMESTART_BCSTARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct READY_EDSTARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct EDEND_DISABLEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct CCAIDLE_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct TXREADY_STARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct RXREADY_STARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct PHYEND_DISABLEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.SHORTS {
    struct PHYEND_STARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CRCSTATUS {
    struct CRCSTATUS_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Packet received with CRC error
        static let CRCError = Self(rawValue: 0x0)

        /// Packet received with CRC ok
        static let CRCOk = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.PDUSTAT {
    struct PDUSTAT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Payload less than PCNF1.MAXLEN
        static let LessThan = Self(rawValue: 0x0)

        /// Payload greater than PCNF1.MAXLEN
        static let GreaterThan = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.PDUSTAT {
    struct CISTATValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Frame is received at 125 kbps
        static let LR125kbit = Self(rawValue: 0x0)

        /// Frame is received at 500 kbps
        static let LR500kbit = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFESTATUS {
    struct SWITCHINGSTATEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// Switching state Idle
        static let Idle = Self(rawValue: 0x0)

        /// Switching state Offset
        static let Offset = Self(rawValue: 0x1)

        /// Switching state Guard
        static let Guard = Self(rawValue: 0x2)

        /// Switching state Ref
        static let Ref = Self(rawValue: 0x3)

        /// Switching state Switching
        static let Switching = Self(rawValue: 0x4)

        /// Switching state Ending
        static let Ending = Self(rawValue: 0x5)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFESTATUS {
    struct SAMPLINGSTATEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Sampling state Idle
        static let Idle = Self(rawValue: 0x0)

        /// Sampling state Sampling
        static let Sampling = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.FREQUENCY {
    struct MAPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Channel map between 2400 MHZ .. 2500 MHz
        static let Default = Self(rawValue: 0x0)

        /// Channel map between 2360 MHZ .. 2460 MHz
        static let Low = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.TXPOWER {
    struct TXPOWER_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 8

        /// +8 dBm
        static let Pos8dBm = Self(rawValue: 0x8)

        /// +7 dBm
        static let Pos7dBm = Self(rawValue: 0x7)

        /// +6 dBm
        static let Pos6dBm = Self(rawValue: 0x6)

        /// +5 dBm
        static let Pos5dBm = Self(rawValue: 0x5)

        /// +4 dBm
        static let Pos4dBm = Self(rawValue: 0x4)

        /// +3 dBm
        static let Pos3dBm = Self(rawValue: 0x3)

        /// +2 dBm
        static let Pos2dBm = Self(rawValue: 0x2)

        /// 0 dBm
        static let _0dBm = Self(rawValue: 0x0)

        /// -4 dBm
        static let Neg4dBm = Self(rawValue: 0xfc)

        /// -8 dBm
        static let Neg8dBm = Self(rawValue: 0xf8)

        /// -12 dBm
        static let Neg12dBm = Self(rawValue: 0xf4)

        /// -16 dBm
        static let Neg16dBm = Self(rawValue: 0xf0)

        /// -20 dBm
        static let Neg20dBm = Self(rawValue: 0xec)

        /// Deprecated enumerator -  -40 dBm
        static let Neg30dBm = Self(rawValue: 0xe2)

        /// -40 dBm
        static let Neg40dBm = Self(rawValue: 0xd8)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.MODE {
    struct MODE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// 1 Mbps Nordic proprietary radio mode
        static let Nrf_1Mbit = Self(rawValue: 0x0)

        /// 2 Mbps Nordic proprietary radio mode
        static let Nrf_2Mbit = Self(rawValue: 0x1)

        /// 1 Mbps BLE
        static let Ble_1Mbit = Self(rawValue: 0x3)

        /// 2 Mbps BLE
        static let Ble_2Mbit = Self(rawValue: 0x4)

        /// Long range 125 kbps TX, 125 kbps and 500 kbps RX
        static let Ble_LR125Kbit = Self(rawValue: 0x5)

        /// Long range 500 kbps TX, 125 kbps and 500 kbps RX
        static let Ble_LR500Kbit = Self(rawValue: 0x6)

        /// IEEE 802.15.4-2006 250 kbps
        static let Ieee802154_250Kbit = Self(rawValue: 0xf)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.PCNF0 {
    struct S1INCLValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// gt; 0
        static let Automatic = Self(rawValue: 0x0)

        /// Always include S1 field in RAM independent of S1LEN
        static let Include = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.PCNF0 {
    struct PLENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// 8-bit preamble
        static let _8bit = Self(rawValue: 0x0)

        /// 16-bit preamble
        static let _16bit = Self(rawValue: 0x1)

        /// 32-bit zero preamble - used for IEEE 802.15.4
        static let _32bitZero = Self(rawValue: 0x2)

        /// Preamble - used for BLE long range
        static let LongRange = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.PCNF0 {
    struct CRCINCValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// LENGTH does not contain CRC
        static let Exclude = Self(rawValue: 0x0)

        /// LENGTH includes CRC
        static let Include = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.PCNF1 {
    struct ENDIANValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Least significant bit on air first
        static let Little = Self(rawValue: 0x0)

        /// Most significant bit on air first
        static let Big = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.PCNF1 {
    struct WHITEENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.RXADDRESSES {
    struct ADDR0Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.RXADDRESSES {
    struct ADDR1Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.RXADDRESSES {
    struct ADDR2Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.RXADDRESSES {
    struct ADDR3Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.RXADDRESSES {
    struct ADDR4Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.RXADDRESSES {
    struct ADDR5Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.RXADDRESSES {
    struct ADDR6Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.RXADDRESSES {
    struct ADDR7Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CRCCNF {
    struct LENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// CRC length is zero and CRC calculation is disabled
        static let Disabled = Self(rawValue: 0x0)

        /// CRC length is one byte and CRC calculation is enabled
        static let One = Self(rawValue: 0x1)

        /// CRC length is two bytes and CRC calculation is enabled
        static let Two = Self(rawValue: 0x2)

        /// CRC length is three bytes and CRC calculation is enabled
        static let Three = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CRCCNF {
    struct SKIPADDRValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// CRC calculation includes address field
        static let Include = Self(rawValue: 0x0)

        /// CRC calculation does not include address field. The CRC calculation will start at the first byte after the address.
        static let Skip = Self(rawValue: 0x1)

        /// CRC calculation as per 802.15.4 standard. Starting at first byte after length field.
        static let Ieee802154 = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.STATE {
    struct STATE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// RADIO is in the Disabled state
        static let Disabled = Self(rawValue: 0x0)

        /// RADIO is in the RXRU state
        static let RxRu = Self(rawValue: 0x1)

        /// RADIO is in the RXIDLE state
        static let RxIdle = Self(rawValue: 0x2)

        /// RADIO is in the RX state
        static let Rx = Self(rawValue: 0x3)

        /// RADIO is in the RXDISABLED state
        static let RxDisable = Self(rawValue: 0x4)

        /// RADIO is in the TXRU state
        static let TxRu = Self(rawValue: 0x9)

        /// RADIO is in the TXIDLE state
        static let TxIdle = Self(rawValue: 0xa)

        /// RADIO is in the TX state
        static let Tx = Self(rawValue: 0xb)

        /// RADIO is in the TXDISABLED state
        static let TxDisable = Self(rawValue: 0xc)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DACNF {
    struct ENA0Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DACNF {
    struct ENA1Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DACNF {
    struct ENA2Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DACNF {
    struct ENA3Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DACNF {
    struct ENA4Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DACNF {
    struct ENA5Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DACNF {
    struct ENA6Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DACNF {
    struct ENA7Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.MODECNF0 {
    struct RUValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Default ramp-up time (tRXEN and tTXEN), compatible with firmware written for nRF51
        static let Default = Self(rawValue: 0x0)

        /// Fast ramp-up (tRXEN,FAST and tTXEN,FAST), see electrical specifications for more information
        static let Fast = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.MODECNF0 {
    struct DTXValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Transmit '1'
        static let B1 = Self(rawValue: 0x0)

        /// Transmit '0'
        static let B0 = Self(rawValue: 0x1)

        /// Transmit center frequency
        static let Center = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CCACTRL {
    struct CCAMODEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// Energy above threshold
        static let EdMode = Self(rawValue: 0x0)

        /// Carrier seen
        static let CarrierMode = Self(rawValue: 0x1)

        /// Energy above threshold AND carrier seen
        static let CarrierAndEdMode = Self(rawValue: 0x2)

        /// Energy above threshold OR carrier seen
        static let CarrierOrEdMode = Self(rawValue: 0x3)

        /// Energy above threshold test mode that will abort when first ED measurement over threshold is seen. No averaging.
        static let EdModeTest1 = Self(rawValue: 0x4)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFEMODE {
    struct DFEOPMODEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Direction finding mode disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Direction finding mode set to AoD
        static let AoD = Self(rawValue: 0x2)

        /// Direction finding mode set to AoA
        static let AoA = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CTEINLINECONF {
    struct CTEINLINECTRLENValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Parsing of CTEInfo is enabled
        static let Enabled = Self(rawValue: 0x1)

        /// Parsing of CTEInfo is disabled
        static let Disabled = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CTEINLINECONF {
    struct CTEINFOINS1Values: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// CTEInfo is in S1 byte (data PDU)
        static let InS1 = Self(rawValue: 0x1)

        /// CTEInfo is NOT in S1 byte (advertising PDU)
        static let NotInS1 = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CTEINLINECONF {
    struct CTEERRORHANDLINGValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Sampling and antenna switching also when CRC is not OK
        static let Yes = Self(rawValue: 0x1)

        /// No sampling and antenna switching when CRC is not OK
        static let No = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CTEINLINECONF {
    struct CTETIMEVALIDRANGEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// 20 in 8 us unit (default) Set to 20 if parsed CTETime is larger than 20
        static let _20 = Self(rawValue: 0x0)

        /// 31 in 8 us unit
        static let _31 = Self(rawValue: 0x1)

        /// 63 in 8 us unit
        static let _63 = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CTEINLINECONF {
    struct CTEINLINERXMODE1USValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// 4 us
        static let _4us = Self(rawValue: 0x1)

        /// 2 us
        static let _2us = Self(rawValue: 0x2)

        /// 1 us
        static let _1us = Self(rawValue: 0x3)

        /// 0.5 us
        static let _500ns = Self(rawValue: 0x4)

        /// 0.25 us
        static let _250ns = Self(rawValue: 0x5)

        /// 0.125 us
        static let _125ns = Self(rawValue: 0x6)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CTEINLINECONF {
    struct CTEINLINERXMODE2USValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// 4 us
        static let _4us = Self(rawValue: 0x1)

        /// 2 us
        static let _2us = Self(rawValue: 0x2)

        /// 1 us
        static let _1us = Self(rawValue: 0x3)

        /// 0.5 us
        static let _500ns = Self(rawValue: 0x4)

        /// 0.25 us
        static let _250ns = Self(rawValue: 0x5)

        /// 0.125 us
        static let _125ns = Self(rawValue: 0x6)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFECTRL1 {
    struct DFEINEXTENSIONValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// AoA/AoD procedure triggered at end of CRC
        static let CRC = Self(rawValue: 0x1)

        /// Antenna switching/sampling is done in the packet payload
        static let Payload = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFECTRL1 {
    struct TSWITCHSPACINGValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// 4 us
        static let _4us = Self(rawValue: 0x1)

        /// 2 us
        static let _2us = Self(rawValue: 0x2)

        /// 1 us
        static let _1us = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFECTRL1 {
    struct TSAMPLESPACINGREFValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// 4 us
        static let _4us = Self(rawValue: 0x1)

        /// 2 us
        static let _2us = Self(rawValue: 0x2)

        /// 1 us
        static let _1us = Self(rawValue: 0x3)

        /// 0.5 us
        static let _500ns = Self(rawValue: 0x4)

        /// 0.25 us
        static let _250ns = Self(rawValue: 0x5)

        /// 0.125 us
        static let _125ns = Self(rawValue: 0x6)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFECTRL1 {
    struct SAMPLETYPEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Complex samples in I and Q
        static let IQ = Self(rawValue: 0x0)

        /// Complex samples as magnitude and phase
        static let MagPhase = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFECTRL1 {
    struct TSAMPLESPACINGValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// 4 us
        static let _4us = Self(rawValue: 0x1)

        /// 2 us
        static let _2us = Self(rawValue: 0x2)

        /// 1 us
        static let _1us = Self(rawValue: 0x3)

        /// 0.5 us
        static let _500ns = Self(rawValue: 0x4)

        /// 0.25 us
        static let _250ns = Self(rawValue: 0x5)

        /// 0.125 us
        static let _125ns = Self(rawValue: 0x6)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.DFECTRL1 {
    struct REPEATPATTERNValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// Do not repeat (1 time in total)
        static let NoRepeat = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.CLEARPATTERN {
    struct CLEARPATTERN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Clear the GPIO pattern
        static let Clear = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.POWER {
    struct POWER_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Peripheral is powered off
        static let Disabled = Self(rawValue: 0x0)

        /// Peripheral is powered on
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension RADIO.PSEL.DFEGPIO {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
