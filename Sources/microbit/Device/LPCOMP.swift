// Generated by svd2swift.

import MMIO

/// Low-power comparator
@RegisterBlock
struct LPCOMP {
    /// Start comparator
    @RegisterBlock(offset: 0x0)
    var tasks_start: Register<TASKS_START>

    /// Stop comparator
    @RegisterBlock(offset: 0x4)
    var tasks_stop: Register<TASKS_STOP>

    /// Sample comparator value
    @RegisterBlock(offset: 0x8)
    var tasks_sample: Register<TASKS_SAMPLE>

    /// LPCOMP is ready and output is valid
    @RegisterBlock(offset: 0x100)
    var events_ready: Register<EVENTS_READY>

    /// Downward crossing
    @RegisterBlock(offset: 0x104)
    var events_down: Register<EVENTS_DOWN>

    /// Upward crossing
    @RegisterBlock(offset: 0x108)
    var events_up: Register<EVENTS_UP>

    /// Downward or upward crossing
    @RegisterBlock(offset: 0x10c)
    var events_cross: Register<EVENTS_CROSS>

    /// Shortcuts between local events and tasks
    @RegisterBlock(offset: 0x200)
    var shorts: Register<SHORTS>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// Compare result
    @RegisterBlock(offset: 0x400)
    var result: Register<RESULT>

    /// Enable LPCOMP
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// Input pin select
    @RegisterBlock(offset: 0x504)
    var psel: Register<PSEL>

    /// Reference select
    @RegisterBlock(offset: 0x508)
    var refsel: Register<REFSEL>

    /// External reference select
    @RegisterBlock(offset: 0x50c)
    var extrefsel: Register<EXTREFSEL>

    /// Analog detect configuration
    @RegisterBlock(offset: 0x520)
    var anadetect: Register<ANADETECT>

    /// Comparator hysteresis enable
    @RegisterBlock(offset: 0x538)
    var hyst: Register<HYST>
}

extension LPCOMP {
    /// Start comparator
    @Register(bitWidth: 32)
    struct TASKS_START {
        /// Start comparator
        @WriteOnly(bits: 0..<1, as: TASKS_START_FIELDValues.self)
        var tasks_start_field: TASKS_START_FIELD
    }

    /// Stop comparator
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stop comparator
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// Sample comparator value
    @Register(bitWidth: 32)
    struct TASKS_SAMPLE {
        /// Sample comparator value
        @WriteOnly(bits: 0..<1, as: TASKS_SAMPLE_FIELDValues.self)
        var tasks_sample_field: TASKS_SAMPLE_FIELD
    }

    /// LPCOMP is ready and output is valid
    @Register(bitWidth: 32)
    struct EVENTS_READY {
        /// LPCOMP is ready and output is valid
        @ReadWrite(bits: 0..<1, as: EVENTS_READY_FIELDValues.self)
        var events_ready_field: EVENTS_READY_FIELD
    }

    /// Downward crossing
    @Register(bitWidth: 32)
    struct EVENTS_DOWN {
        /// Downward crossing
        @ReadWrite(bits: 0..<1, as: EVENTS_DOWN_FIELDValues.self)
        var events_down_field: EVENTS_DOWN_FIELD
    }

    /// Upward crossing
    @Register(bitWidth: 32)
    struct EVENTS_UP {
        /// Upward crossing
        @ReadWrite(bits: 0..<1, as: EVENTS_UP_FIELDValues.self)
        var events_up_field: EVENTS_UP_FIELD
    }

    /// Downward or upward crossing
    @Register(bitWidth: 32)
    struct EVENTS_CROSS {
        /// Downward or upward crossing
        @ReadWrite(bits: 0..<1, as: EVENTS_CROSS_FIELDValues.self)
        var events_cross_field: EVENTS_CROSS_FIELD
    }

    /// Shortcuts between local events and tasks
    @Register(bitWidth: 32)
    struct SHORTS {
        /// Shortcut between event READY and task SAMPLE
        @ReadWrite(bits: 0..<1, as: READY_SAMPLEValues.self)
        var ready_sample: READY_SAMPLE

        /// Shortcut between event READY and task STOP
        @ReadWrite(bits: 1..<2, as: READY_STOPValues.self)
        var ready_stop: READY_STOP

        /// Shortcut between event DOWN and task STOP
        @ReadWrite(bits: 2..<3, as: DOWN_STOPValues.self)
        var down_stop: DOWN_STOP

        /// Shortcut between event UP and task STOP
        @ReadWrite(bits: 3..<4, as: UP_STOPValues.self)
        var up_stop: UP_STOP

        /// Shortcut between event CROSS and task STOP
        @ReadWrite(bits: 4..<5, as: CROSS_STOPValues.self)
        var cross_stop: CROSS_STOP
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event READY
        @ReadWrite(bits: 0..<1)
        var ready: READY

        /// Write '1' to enable interrupt for event DOWN
        @ReadWrite(bits: 1..<2)
        var down: DOWN

        /// Write '1' to enable interrupt for event UP
        @ReadWrite(bits: 2..<3)
        var up: UP

        /// Write '1' to enable interrupt for event CROSS
        @ReadWrite(bits: 3..<4)
        var cross: CROSS
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event READY
        @ReadWrite(bits: 0..<1)
        var ready: READY

        /// Write '1' to disable interrupt for event DOWN
        @ReadWrite(bits: 1..<2)
        var down: DOWN

        /// Write '1' to disable interrupt for event UP
        @ReadWrite(bits: 2..<3)
        var up: UP

        /// Write '1' to disable interrupt for event CROSS
        @ReadWrite(bits: 3..<4)
        var cross: CROSS
    }

    /// Compare result
    @Register(bitWidth: 32)
    struct RESULT {
        /// Result of last compare. Decision point SAMPLE task.
        @ReadOnly(bits: 0..<1, as: RESULT_FIELDValues.self)
        var result_field: RESULT_FIELD
    }

    /// Enable LPCOMP
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable or disable LPCOMP
        @ReadWrite(bits: 0..<2, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// Input pin select
    @Register(bitWidth: 32)
    struct PSEL {
        /// Analog pin select
        @ReadWrite(bits: 0..<3, as: PSEL_FIELDValues.self)
        var psel_field: PSEL_FIELD
    }

    /// Reference select
    @Register(bitWidth: 32)
    struct REFSEL {
        /// Reference select
        @ReadWrite(bits: 0..<4, as: REFSEL_FIELDValues.self)
        var refsel_field: REFSEL_FIELD
    }

    /// External reference select
    @Register(bitWidth: 32)
    struct EXTREFSEL {
        /// External analog reference select
        @ReadWrite(bits: 0..<1, as: EXTREFSEL_FIELDValues.self)
        var extrefsel_field: EXTREFSEL_FIELD
    }

    /// Analog detect configuration
    @Register(bitWidth: 32)
    struct ANADETECT {
        /// Analog detect configuration
        @ReadWrite(bits: 0..<2, as: ANADETECT_FIELDValues.self)
        var anadetect_field: ANADETECT_FIELD
    }

    /// Comparator hysteresis enable
    @Register(bitWidth: 32)
    struct HYST {
        /// Comparator hysteresis enable
        @ReadWrite(bits: 0..<1, as: HYST_FIELDValues.self)
        var hyst_field: HYST_FIELD
    }
}

extension LPCOMP.TASKS_START {
    struct TASKS_START_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.TASKS_SAMPLE {
    struct TASKS_SAMPLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.EVENTS_READY {
    struct EVENTS_READY_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.EVENTS_DOWN {
    struct EVENTS_DOWN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.EVENTS_UP {
    struct EVENTS_UP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.EVENTS_CROSS {
    struct EVENTS_CROSS_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.SHORTS {
    struct READY_SAMPLEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.SHORTS {
    struct READY_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.SHORTS {
    struct DOWN_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.SHORTS {
    struct UP_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.SHORTS {
    struct CROSS_STOPValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.RESULT {
    struct RESULT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// lt; VIN-)
        static let Below = Self(rawValue: 0x0)

        /// gt; VIN-)
        static let Above = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.PSEL {
    struct PSEL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// AIN0 selected as analog input
        static let AnalogInput0 = Self(rawValue: 0x0)

        /// AIN1 selected as analog input
        static let AnalogInput1 = Self(rawValue: 0x1)

        /// AIN2 selected as analog input
        static let AnalogInput2 = Self(rawValue: 0x2)

        /// AIN3 selected as analog input
        static let AnalogInput3 = Self(rawValue: 0x3)

        /// AIN4 selected as analog input
        static let AnalogInput4 = Self(rawValue: 0x4)

        /// AIN5 selected as analog input
        static let AnalogInput5 = Self(rawValue: 0x5)

        /// AIN6 selected as analog input
        static let AnalogInput6 = Self(rawValue: 0x6)

        /// AIN7 selected as analog input
        static let AnalogInput7 = Self(rawValue: 0x7)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.REFSEL {
    struct REFSEL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// VDD * 1/8 selected as reference
        static let Ref1_8Vdd = Self(rawValue: 0x0)

        /// VDD * 2/8 selected as reference
        static let Ref2_8Vdd = Self(rawValue: 0x1)

        /// VDD * 3/8 selected as reference
        static let Ref3_8Vdd = Self(rawValue: 0x2)

        /// VDD * 4/8 selected as reference
        static let Ref4_8Vdd = Self(rawValue: 0x3)

        /// VDD * 5/8 selected as reference
        static let Ref5_8Vdd = Self(rawValue: 0x4)

        /// VDD * 6/8 selected as reference
        static let Ref6_8Vdd = Self(rawValue: 0x5)

        /// VDD * 7/8 selected as reference
        static let Ref7_8Vdd = Self(rawValue: 0x6)

        /// External analog reference selected
        static let ARef = Self(rawValue: 0x7)

        /// VDD * 1/16 selected as reference
        static let Ref1_16Vdd = Self(rawValue: 0x8)

        /// VDD * 3/16 selected as reference
        static let Ref3_16Vdd = Self(rawValue: 0x9)

        /// VDD * 5/16 selected as reference
        static let Ref5_16Vdd = Self(rawValue: 0xa)

        /// VDD * 7/16 selected as reference
        static let Ref7_16Vdd = Self(rawValue: 0xb)

        /// VDD * 9/16 selected as reference
        static let Ref9_16Vdd = Self(rawValue: 0xc)

        /// VDD * 11/16 selected as reference
        static let Ref11_16Vdd = Self(rawValue: 0xd)

        /// VDD * 13/16 selected as reference
        static let Ref13_16Vdd = Self(rawValue: 0xe)

        /// VDD * 15/16 selected as reference
        static let Ref15_16Vdd = Self(rawValue: 0xf)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.EXTREFSEL {
    struct EXTREFSEL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Use AIN0 as external analog reference
        static let AnalogReference0 = Self(rawValue: 0x0)

        /// Use AIN1 as external analog reference
        static let AnalogReference1 = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.ANADETECT {
    struct ANADETECT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Generate ANADETECT on crossing, both upward crossing and downward crossing
        static let Cross = Self(rawValue: 0x0)

        /// Generate ANADETECT on upward crossing only
        static let Up = Self(rawValue: 0x1)

        /// Generate ANADETECT on downward crossing only
        static let Down = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension LPCOMP.HYST {
    struct HYST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Comparator hysteresis disabled
        static let Disabled = Self(rawValue: 0x0)

        /// Comparator hysteresis enabled
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
