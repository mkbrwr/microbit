// Generated by svd2swift.

import MMIO

/// Inter-IC Sound
@RegisterBlock
struct I2S {
    /// Starts continuous I2S transfer. Also starts MCK generator when this is enabled.
    @RegisterBlock(offset: 0x0)
    var tasks_start: Register<TASKS_START>

    /// Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated.
    @RegisterBlock(offset: 0x4)
    var tasks_stop: Register<TASKS_STOP>

    /// When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin.
    @RegisterBlock(offset: 0x104)
    var events_rxptrupd: Register<EVENTS_RXPTRUPD>

    /// I2S transfer stopped.
    @RegisterBlock(offset: 0x108)
    var events_stopped: Register<EVENTS_STOPPED>

    /// When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
    @RegisterBlock(offset: 0x114)
    var events_txptrupd: Register<EVENTS_TXPTRUPD>

    /// Enable or disable interrupt
    @RegisterBlock(offset: 0x300)
    var inten: Register<INTEN>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// Enable I2S module.
    @RegisterBlock(offset: 0x500)
    var enable: Register<ENABLE>

    /// Unspecified
    @RegisterBlock(offset: 0x504)
    var config: CONFIG

    /// Unspecified
    @RegisterBlock(offset: 0x538)
    var rxd: RXD

    /// Unspecified
    @RegisterBlock(offset: 0x540)
    var txd: TXD

    /// Unspecified
    @RegisterBlock(offset: 0x550)
    var rxtxd: RXTXD

    /// Unspecified
    @RegisterBlock(offset: 0x560)
    var psel: PSEL
}

extension I2S {
    /// Starts continuous I2S transfer. Also starts MCK generator when this is enabled.
    @Register(bitWidth: 32)
    struct TASKS_START {
        /// Starts continuous I2S transfer. Also starts MCK generator when this is enabled.
        @WriteOnly(bits: 0..<1, as: TASKS_START_FIELDValues.self)
        var tasks_start_field: TASKS_START_FIELD
    }

    /// Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated.
    @Register(bitWidth: 32)
    struct TASKS_STOP {
        /// Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated.
        @WriteOnly(bits: 0..<1, as: TASKS_STOP_FIELDValues.self)
        var tasks_stop_field: TASKS_STOP_FIELD
    }

    /// When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin.
    @Register(bitWidth: 32)
    struct EVENTS_RXPTRUPD {
        /// When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin.
        @ReadWrite(bits: 0..<1, as: EVENTS_RXPTRUPD_FIELDValues.self)
        var events_rxptrupd_field: EVENTS_RXPTRUPD_FIELD
    }

    /// I2S transfer stopped.
    @Register(bitWidth: 32)
    struct EVENTS_STOPPED {
        /// I2S transfer stopped.
        @ReadWrite(bits: 0..<1, as: EVENTS_STOPPED_FIELDValues.self)
        var events_stopped_field: EVENTS_STOPPED_FIELD
    }

    /// When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
    @Register(bitWidth: 32)
    struct EVENTS_TXPTRUPD {
        /// When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
        @ReadWrite(bits: 0..<1, as: EVENTS_TXPTRUPD_FIELDValues.self)
        var events_txptrupd_field: EVENTS_TXPTRUPD_FIELD
    }

    /// Enable or disable interrupt
    @Register(bitWidth: 32)
    struct INTEN {
        /// Enable or disable interrupt for event RXPTRUPD
        @ReadWrite(bits: 1..<2, as: RXPTRUPDValues.self)
        var rxptrupd: RXPTRUPD

        /// Enable or disable interrupt for event STOPPED
        @ReadWrite(bits: 2..<3, as: STOPPEDValues.self)
        var stopped: STOPPED

        /// Enable or disable interrupt for event TXPTRUPD
        @ReadWrite(bits: 5..<6, as: TXPTRUPDValues.self)
        var txptrupd: TXPTRUPD
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event RXPTRUPD
        @ReadWrite(bits: 1..<2)
        var rxptrupd: RXPTRUPD

        /// Write '1' to enable interrupt for event STOPPED
        @ReadWrite(bits: 2..<3)
        var stopped: STOPPED

        /// Write '1' to enable interrupt for event TXPTRUPD
        @ReadWrite(bits: 5..<6)
        var txptrupd: TXPTRUPD
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event RXPTRUPD
        @ReadWrite(bits: 1..<2)
        var rxptrupd: RXPTRUPD

        /// Write '1' to disable interrupt for event STOPPED
        @ReadWrite(bits: 2..<3)
        var stopped: STOPPED

        /// Write '1' to disable interrupt for event TXPTRUPD
        @ReadWrite(bits: 5..<6)
        var txptrupd: TXPTRUPD
    }

    /// Enable I2S module.
    @Register(bitWidth: 32)
    struct ENABLE {
        /// Enable I2S module.
        @ReadWrite(bits: 0..<1, as: ENABLE_FIELDValues.self)
        var enable_field: ENABLE_FIELD
    }

    /// Unspecified
    @RegisterBlock
    struct CONFIG {
        /// I2S mode.
        @RegisterBlock(offset: 0x0)
        var mode: Register<MODE>

        /// Reception (RX) enable.
        @RegisterBlock(offset: 0x4)
        var rxen: Register<RXEN>

        /// Transmission (TX) enable.
        @RegisterBlock(offset: 0x8)
        var txen: Register<TXEN>

        /// Master clock generator enable.
        @RegisterBlock(offset: 0xc)
        var mcken: Register<MCKEN>

        /// Master clock generator frequency.
        @RegisterBlock(offset: 0x10)
        var mckfreq: Register<MCKFREQ>

        /// MCK / LRCK ratio.
        @RegisterBlock(offset: 0x14)
        var ratio: Register<RATIO>

        /// Sample width.
        @RegisterBlock(offset: 0x18)
        var swidth: Register<SWIDTH>

        /// Alignment of sample within a frame.
        @RegisterBlock(offset: 0x1c)
        var align: Register<ALIGN>

        /// Frame format.
        @RegisterBlock(offset: 0x20)
        var format: Register<FORMAT>

        /// Enable channels.
        @RegisterBlock(offset: 0x24)
        var channels: Register<CHANNELS>
    }

    /// Unspecified
    @RegisterBlock
    struct RXD {
        /// Receive buffer RAM start address.
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>
    }

    /// Unspecified
    @RegisterBlock
    struct TXD {
        /// Transmit buffer RAM start address.
        @RegisterBlock(offset: 0x0)
        var ptr: Register<PTR>
    }

    /// Unspecified
    @RegisterBlock
    struct RXTXD {
        /// Size of RXD and TXD buffers.
        @RegisterBlock(offset: 0x0)
        var maxcnt: Register<MAXCNT>
    }

    /// Unspecified
    @RegisterBlock
    struct PSEL {
        /// Pin select for MCK signal.
        @RegisterBlock(offset: 0x0)
        var mck: Register<MCK>

        /// Pin select for SCK signal.
        @RegisterBlock(offset: 0x4)
        var sck: Register<SCK>

        /// Pin select for LRCK signal.
        @RegisterBlock(offset: 0x8)
        var lrck: Register<LRCK>

        /// Pin select for SDIN signal.
        @RegisterBlock(offset: 0xc)
        var sdin: Register<SDIN>

        /// Pin select for SDOUT signal.
        @RegisterBlock(offset: 0x10)
        var sdout: Register<SDOUT>
    }
}

extension I2S.CONFIG {
    /// I2S mode.
    @Register(bitWidth: 32)
    struct MODE {
        /// I2S mode.
        @ReadWrite(bits: 0..<1, as: MODE_FIELDValues.self)
        var mode_field: MODE_FIELD
    }

    /// Reception (RX) enable.
    @Register(bitWidth: 32)
    struct RXEN {
        /// Reception (RX) enable.
        @ReadWrite(bits: 0..<1, as: RXEN_FIELDValues.self)
        var rxen_field: RXEN_FIELD
    }

    /// Transmission (TX) enable.
    @Register(bitWidth: 32)
    struct TXEN {
        /// Transmission (TX) enable.
        @ReadWrite(bits: 0..<1, as: TXEN_FIELDValues.self)
        var txen_field: TXEN_FIELD
    }

    /// Master clock generator enable.
    @Register(bitWidth: 32)
    struct MCKEN {
        /// Master clock generator enable.
        @ReadWrite(bits: 0..<1, as: MCKEN_FIELDValues.self)
        var mcken_field: MCKEN_FIELD
    }

    /// Master clock generator frequency.
    @Register(bitWidth: 32)
    struct MCKFREQ {
        /// Master clock generator frequency.
        @ReadWrite(bits: 0..<32, as: MCKFREQ_FIELDValues.self)
        var mckfreq_field: MCKFREQ_FIELD
    }

    /// MCK / LRCK ratio.
    @Register(bitWidth: 32)
    struct RATIO {
        /// MCK / LRCK ratio.
        @ReadWrite(bits: 0..<4, as: RATIO_FIELDValues.self)
        var ratio_field: RATIO_FIELD
    }

    /// Sample width.
    @Register(bitWidth: 32)
    struct SWIDTH {
        /// Sample width.
        @ReadWrite(bits: 0..<2, as: SWIDTH_FIELDValues.self)
        var swidth_field: SWIDTH_FIELD
    }

    /// Alignment of sample within a frame.
    @Register(bitWidth: 32)
    struct ALIGN {
        /// Alignment of sample within a frame.
        @ReadWrite(bits: 0..<1, as: ALIGN_FIELDValues.self)
        var align_field: ALIGN_FIELD
    }

    /// Frame format.
    @Register(bitWidth: 32)
    struct FORMAT {
        /// Frame format.
        @ReadWrite(bits: 0..<1, as: FORMAT_FIELDValues.self)
        var format_field: FORMAT_FIELD
    }

    /// Enable channels.
    @Register(bitWidth: 32)
    struct CHANNELS {
        /// Enable channels.
        @ReadWrite(bits: 0..<2, as: CHANNELS_FIELDValues.self)
        var channels_field: CHANNELS_FIELD
    }
}

extension I2S.RXD {
    /// Receive buffer RAM start address.
    @Register(bitWidth: 32)
    struct PTR {
        /// Receive buffer Data RAM start address. When receiving, words containing samples will be written to this address. This address is a word aligned Data RAM address.
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }
}

extension I2S.TXD {
    /// Transmit buffer RAM start address.
    @Register(bitWidth: 32)
    struct PTR {
        /// Transmit buffer Data RAM start address. When transmitting, words containing samples will be fetched from this address. This address is a word aligned Data RAM address.
        @ReadWrite(bits: 0..<32)
        var ptr_field: PTR_FIELD
    }
}

extension I2S.RXTXD {
    /// Size of RXD and TXD buffers.
    @Register(bitWidth: 32)
    struct MAXCNT {
        /// Size of RXD and TXD buffers in number of 32 bit words.
        @ReadWrite(bits: 0..<14)
        var maxcnt_field: MAXCNT_FIELD
    }
}

extension I2S.PSEL {
    /// Pin select for MCK signal.
    @Register(bitWidth: 32)
    struct MCK {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for SCK signal.
    @Register(bitWidth: 32)
    struct SCK {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for LRCK signal.
    @Register(bitWidth: 32)
    struct LRCK {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for SDIN signal.
    @Register(bitWidth: 32)
    struct SDIN {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Pin select for SDOUT signal.
    @Register(bitWidth: 32)
    struct SDOUT {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }
}

extension I2S.TASKS_START {
    struct TASKS_START_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.TASKS_STOP {
    struct TASKS_STOP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.EVENTS_RXPTRUPD {
    struct EVENTS_RXPTRUPD_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.EVENTS_STOPPED {
    struct EVENTS_STOPPED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.EVENTS_TXPTRUPD {
    struct EVENTS_TXPTRUPD_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.INTEN {
    struct RXPTRUPDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.INTEN {
    struct STOPPEDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.INTEN {
    struct TXPTRUPDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.ENABLE {
    struct ENABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.MODE {
    struct MODE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx.
        static let Master = Self(rawValue: 0x0)

        /// Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx
        static let Slave = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.RXEN {
    struct RXEN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Reception disabled and now data will be written to the RXD.PTR address.
        static let Disabled = Self(rawValue: 0x0)

        /// Reception enabled.
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.TXEN {
    struct TXEN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Transmission disabled and now data will be read from the RXD.TXD address.
        static let Disabled = Self(rawValue: 0x0)

        /// Transmission enabled.
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.MCKEN {
    struct MCKEN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Master clock generator disabled and PSEL.MCK not connected(available as GPIO).
        static let Disabled = Self(rawValue: 0x0)

        /// Master clock generator running and MCK output on PSEL.MCK.
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.MCKFREQ {
    struct MCKFREQ_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 32

        /// 32 MHz / 8 = 4.0 MHz
        static let _32MDIV8 = Self(rawValue: 0x20000000)

        /// 32 MHz / 10 = 3.2 MHz
        static let _32MDIV10 = Self(rawValue: 0x18000000)

        /// 32 MHz / 11 = 2.9090909 MHz
        static let _32MDIV11 = Self(rawValue: 0x16000000)

        /// 32 MHz / 15 = 2.1333333 MHz
        static let _32MDIV15 = Self(rawValue: 0x11000000)

        /// 32 MHz / 16 = 2.0 MHz
        static let _32MDIV16 = Self(rawValue: 0x10000000)

        /// 32 MHz / 21 = 1.5238095
        static let _32MDIV21 = Self(rawValue: 0xc000000)

        /// 32 MHz / 23 = 1.3913043 MHz
        static let _32MDIV23 = Self(rawValue: 0xb000000)

        /// 32 MHz / 30 = 1.0666667 MHz
        static let _32MDIV30 = Self(rawValue: 0x8800000)

        /// 32 MHz / 31 = 1.0322581 MHz
        static let _32MDIV31 = Self(rawValue: 0x8400000)

        /// 32 MHz / 32 = 1.0 MHz
        static let _32MDIV32 = Self(rawValue: 0x8000000)

        /// 32 MHz / 42 = 0.7619048 MHz
        static let _32MDIV42 = Self(rawValue: 0x6000000)

        /// 32 MHz / 63 = 0.5079365 MHz
        static let _32MDIV63 = Self(rawValue: 0x4100000)

        /// 32 MHz / 125 = 0.256 MHz
        static let _32MDIV125 = Self(rawValue: 0x20c0000)

        var rawValue: UInt32

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.RATIO {
    struct RATIO_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 4

        /// LRCK = MCK / 32
        static let _32X = Self(rawValue: 0x0)

        /// LRCK = MCK / 48
        static let _48X = Self(rawValue: 0x1)

        /// LRCK = MCK / 64
        static let _64X = Self(rawValue: 0x2)

        /// LRCK = MCK / 96
        static let _96X = Self(rawValue: 0x3)

        /// LRCK = MCK / 128
        static let _128X = Self(rawValue: 0x4)

        /// LRCK = MCK / 192
        static let _192X = Self(rawValue: 0x5)

        /// LRCK = MCK / 256
        static let _256X = Self(rawValue: 0x6)

        /// LRCK = MCK / 384
        static let _384X = Self(rawValue: 0x7)

        /// LRCK = MCK / 512
        static let _512X = Self(rawValue: 0x8)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.SWIDTH {
    struct SWIDTH_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// 8 bit.
        static let _8Bit = Self(rawValue: 0x0)

        /// 16 bit.
        static let _16Bit = Self(rawValue: 0x1)

        /// 24 bit.
        static let _24Bit = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.ALIGN {
    struct ALIGN_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Left-aligned.
        static let Left = Self(rawValue: 0x0)

        /// Right-aligned.
        static let Right = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.FORMAT {
    struct FORMAT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Original I2S format.
        static let I2S = Self(rawValue: 0x0)

        /// Alternate (left- or right-aligned) format.
        static let Aligned = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.CONFIG.CHANNELS {
    struct CHANNELS_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Stereo.
        static let Stereo = Self(rawValue: 0x0)

        /// Left only.
        static let Left = Self(rawValue: 0x1)

        /// Right only.
        static let Right = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.PSEL.MCK {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.PSEL.SCK {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.PSEL.LRCK {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.PSEL.SDIN {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension I2S.PSEL.SDOUT {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
