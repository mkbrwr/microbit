// Generated by svd2swift.

import MMIO

/// NFC-A compatible radio
@RegisterBlock
struct NFCT {
    /// Activate NFCT peripheral for incoming and outgoing frames, change state to activated
    @RegisterBlock(offset: 0x0)
    var tasks_activate: Register<TASKS_ACTIVATE>

    /// Disable NFCT peripheral
    @RegisterBlock(offset: 0x4)
    var tasks_disable: Register<TASKS_DISABLE>

    /// Enable NFC sense field mode, change state to sense mode
    @RegisterBlock(offset: 0x8)
    var tasks_sense: Register<TASKS_SENSE>

    /// Start transmission of an outgoing frame, change state to transmit
    @RegisterBlock(offset: 0xc)
    var tasks_starttx: Register<TASKS_STARTTX>

    /// Initializes the EasyDMA for receive.
    @RegisterBlock(offset: 0x1c)
    var tasks_enablerxdata: Register<TASKS_ENABLERXDATA>

    /// Force state machine to IDLE state
    @RegisterBlock(offset: 0x24)
    var tasks_goidle: Register<TASKS_GOIDLE>

    /// Force state machine to SLEEP_A state
    @RegisterBlock(offset: 0x28)
    var tasks_gosleep: Register<TASKS_GOSLEEP>

    /// The NFCT peripheral is ready to receive and send frames
    @RegisterBlock(offset: 0x100)
    var events_ready: Register<EVENTS_READY>

    /// Remote NFC field detected
    @RegisterBlock(offset: 0x104)
    var events_fielddetected: Register<EVENTS_FIELDDETECTED>

    /// Remote NFC field lost
    @RegisterBlock(offset: 0x108)
    var events_fieldlost: Register<EVENTS_FIELDLOST>

    /// Marks the start of the first symbol of a transmitted frame
    @RegisterBlock(offset: 0x10c)
    var events_txframestart: Register<EVENTS_TXFRAMESTART>

    /// Marks the end of the last transmitted on-air symbol of a frame
    @RegisterBlock(offset: 0x110)
    var events_txframeend: Register<EVENTS_TXFRAMEEND>

    /// Marks the end of the first symbol of a received frame
    @RegisterBlock(offset: 0x114)
    var events_rxframestart: Register<EVENTS_RXFRAMESTART>

    /// Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer
    @RegisterBlock(offset: 0x118)
    var events_rxframeend: Register<EVENTS_RXFRAMEEND>

    /// NFC error reported. The ERRORSTATUS register contains details on the source of the error.
    @RegisterBlock(offset: 0x11c)
    var events_error: Register<EVENTS_ERROR>

    /// NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error.
    @RegisterBlock(offset: 0x128)
    var events_rxerror: Register<EVENTS_RXERROR>

    /// RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
    @RegisterBlock(offset: 0x12c)
    var events_endrx: Register<EVENTS_ENDRX>

    /// Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer
    @RegisterBlock(offset: 0x130)
    var events_endtx: Register<EVENTS_ENDTX>

    /// Auto collision resolution process has started
    @RegisterBlock(offset: 0x138)
    var events_autocolresstarted: Register<EVENTS_AUTOCOLRESSTARTED>

    /// NFC auto collision resolution error reported.
    @RegisterBlock(offset: 0x148)
    var events_collision: Register<EVENTS_COLLISION>

    /// NFC auto collision resolution successfully completed
    @RegisterBlock(offset: 0x14c)
    var events_selected: Register<EVENTS_SELECTED>

    /// EasyDMA is ready to receive or send frames.
    @RegisterBlock(offset: 0x150)
    var events_started: Register<EVENTS_STARTED>

    /// Shortcuts between local events and tasks
    @RegisterBlock(offset: 0x200)
    var shorts: Register<SHORTS>

    /// Enable or disable interrupt
    @RegisterBlock(offset: 0x300)
    var inten: Register<INTEN>

    /// Enable interrupt
    @RegisterBlock(offset: 0x304)
    var intenset: Register<INTENSET>

    /// Disable interrupt
    @RegisterBlock(offset: 0x308)
    var intenclr: Register<INTENCLR>

    /// NFC Error Status register
    @RegisterBlock(offset: 0x404)
    var errorstatus: Register<ERRORSTATUS>

    /// NfcTag state register
    @RegisterBlock(offset: 0x410)
    var nfctagstate: Register<NFCTAGSTATE>

    /// Sleep state during automatic collision resolution
    @RegisterBlock(offset: 0x420)
    var sleepstate: Register<SLEEPSTATE>

    /// Indicates the presence or not of a valid field
    @RegisterBlock(offset: 0x43c)
    var fieldpresent: Register<FIELDPRESENT>

    /// Minimum frame delay
    @RegisterBlock(offset: 0x504)
    var framedelaymin: Register<FRAMEDELAYMIN>

    /// Maximum frame delay
    @RegisterBlock(offset: 0x508)
    var framedelaymax: Register<FRAMEDELAYMAX>

    /// Configuration register for the Frame Delay Timer
    @RegisterBlock(offset: 0x50c)
    var framedelaymode: Register<FRAMEDELAYMODE>

    /// Packet pointer for TXD and RXD data storage in Data RAM
    @RegisterBlock(offset: 0x510)
    var packetptr: Register<PACKETPTR>

    /// Size of the RAM buffer allocated to TXD and RXD data storage each
    @RegisterBlock(offset: 0x514)
    var maxlen: Register<MAXLEN>

    /// Enables the modulation output to a GPIO pin which can be connected to a second external antenna.
    @RegisterBlock(offset: 0x52c)
    var modulationctrl: Register<MODULATIONCTRL>

    /// Pin select for Modulation control.
    @RegisterBlock(offset: 0x538)
    var modulationpsel: Register<MODULATIONPSEL>

    /// Last NFCID1 part (4, 7 or 10 bytes ID)
    @RegisterBlock(offset: 0x590)
    var nfcid1_last: Register<NFCID1_LAST>

    /// Second last NFCID1 part (7 or 10 bytes ID)
    @RegisterBlock(offset: 0x594)
    var nfcid1_2nd_last: Register<NFCID1_2ND_LAST>

    /// Third last NFCID1 part (10 bytes ID)
    @RegisterBlock(offset: 0x598)
    var nfcid1_3rd_last: Register<NFCID1_3RD_LAST>

    /// Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated.
    @RegisterBlock(offset: 0x59c)
    var autocolresconfig: Register<AUTOCOLRESCONFIG>

    /// NFC-A SENS_RES auto-response settings
    @RegisterBlock(offset: 0x5a0)
    var sensres: Register<SENSRES>

    /// NFC-A SEL_RES auto-response settings
    @RegisterBlock(offset: 0x5a4)
    var selres: Register<SELRES>

    /// Unspecified
    @RegisterBlock(offset: 0x40c)
    var framestatus: FRAMESTATUS

    /// Unspecified
    @RegisterBlock(offset: 0x518)
    var txd: TXD

    /// Unspecified
    @RegisterBlock(offset: 0x520)
    var rxd: RXD
}

extension NFCT {
    /// Activate NFCT peripheral for incoming and outgoing frames, change state to activated
    @Register(bitWidth: 32)
    struct TASKS_ACTIVATE {
        /// Activate NFCT peripheral for incoming and outgoing frames, change state to activated
        @WriteOnly(bits: 0..<1, as: TASKS_ACTIVATE_FIELDValues.self)
        var tasks_activate_field: TASKS_ACTIVATE_FIELD
    }

    /// Disable NFCT peripheral
    @Register(bitWidth: 32)
    struct TASKS_DISABLE {
        /// Disable NFCT peripheral
        @WriteOnly(bits: 0..<1, as: TASKS_DISABLE_FIELDValues.self)
        var tasks_disable_field: TASKS_DISABLE_FIELD
    }

    /// Enable NFC sense field mode, change state to sense mode
    @Register(bitWidth: 32)
    struct TASKS_SENSE {
        /// Enable NFC sense field mode, change state to sense mode
        @WriteOnly(bits: 0..<1, as: TASKS_SENSE_FIELDValues.self)
        var tasks_sense_field: TASKS_SENSE_FIELD
    }

    /// Start transmission of an outgoing frame, change state to transmit
    @Register(bitWidth: 32)
    struct TASKS_STARTTX {
        /// Start transmission of an outgoing frame, change state to transmit
        @WriteOnly(bits: 0..<1, as: TASKS_STARTTX_FIELDValues.self)
        var tasks_starttx_field: TASKS_STARTTX_FIELD
    }

    /// Initializes the EasyDMA for receive.
    @Register(bitWidth: 32)
    struct TASKS_ENABLERXDATA {
        /// Initializes the EasyDMA for receive.
        @WriteOnly(bits: 0..<1, as: TASKS_ENABLERXDATA_FIELDValues.self)
        var tasks_enablerxdata_field: TASKS_ENABLERXDATA_FIELD
    }

    /// Force state machine to IDLE state
    @Register(bitWidth: 32)
    struct TASKS_GOIDLE {
        /// Force state machine to IDLE state
        @WriteOnly(bits: 0..<1, as: TASKS_GOIDLE_FIELDValues.self)
        var tasks_goidle_field: TASKS_GOIDLE_FIELD
    }

    /// Force state machine to SLEEP_A state
    @Register(bitWidth: 32)
    struct TASKS_GOSLEEP {
        /// Force state machine to SLEEP_A state
        @WriteOnly(bits: 0..<1, as: TASKS_GOSLEEP_FIELDValues.self)
        var tasks_gosleep_field: TASKS_GOSLEEP_FIELD
    }

    /// The NFCT peripheral is ready to receive and send frames
    @Register(bitWidth: 32)
    struct EVENTS_READY {
        /// The NFCT peripheral is ready to receive and send frames
        @ReadWrite(bits: 0..<1, as: EVENTS_READY_FIELDValues.self)
        var events_ready_field: EVENTS_READY_FIELD
    }

    /// Remote NFC field detected
    @Register(bitWidth: 32)
    struct EVENTS_FIELDDETECTED {
        /// Remote NFC field detected
        @ReadWrite(bits: 0..<1, as: EVENTS_FIELDDETECTED_FIELDValues.self)
        var events_fielddetected_field: EVENTS_FIELDDETECTED_FIELD
    }

    /// Remote NFC field lost
    @Register(bitWidth: 32)
    struct EVENTS_FIELDLOST {
        /// Remote NFC field lost
        @ReadWrite(bits: 0..<1, as: EVENTS_FIELDLOST_FIELDValues.self)
        var events_fieldlost_field: EVENTS_FIELDLOST_FIELD
    }

    /// Marks the start of the first symbol of a transmitted frame
    @Register(bitWidth: 32)
    struct EVENTS_TXFRAMESTART {
        /// Marks the start of the first symbol of a transmitted frame
        @ReadWrite(bits: 0..<1, as: EVENTS_TXFRAMESTART_FIELDValues.self)
        var events_txframestart_field: EVENTS_TXFRAMESTART_FIELD
    }

    /// Marks the end of the last transmitted on-air symbol of a frame
    @Register(bitWidth: 32)
    struct EVENTS_TXFRAMEEND {
        /// Marks the end of the last transmitted on-air symbol of a frame
        @ReadWrite(bits: 0..<1, as: EVENTS_TXFRAMEEND_FIELDValues.self)
        var events_txframeend_field: EVENTS_TXFRAMEEND_FIELD
    }

    /// Marks the end of the first symbol of a received frame
    @Register(bitWidth: 32)
    struct EVENTS_RXFRAMESTART {
        /// Marks the end of the first symbol of a received frame
        @ReadWrite(bits: 0..<1, as: EVENTS_RXFRAMESTART_FIELDValues.self)
        var events_rxframestart_field: EVENTS_RXFRAMESTART_FIELD
    }

    /// Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer
    @Register(bitWidth: 32)
    struct EVENTS_RXFRAMEEND {
        /// Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer
        @ReadWrite(bits: 0..<1, as: EVENTS_RXFRAMEEND_FIELDValues.self)
        var events_rxframeend_field: EVENTS_RXFRAMEEND_FIELD
    }

    /// NFC error reported. The ERRORSTATUS register contains details on the source of the error.
    @Register(bitWidth: 32)
    struct EVENTS_ERROR {
        /// NFC error reported. The ERRORSTATUS register contains details on the source of the error.
        @ReadWrite(bits: 0..<1, as: EVENTS_ERROR_FIELDValues.self)
        var events_error_field: EVENTS_ERROR_FIELD
    }

    /// NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error.
    @Register(bitWidth: 32)
    struct EVENTS_RXERROR {
        /// NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error.
        @ReadWrite(bits: 0..<1, as: EVENTS_RXERROR_FIELDValues.self)
        var events_rxerror_field: EVENTS_RXERROR_FIELD
    }

    /// RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
    @Register(bitWidth: 32)
    struct EVENTS_ENDRX {
        /// RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
        @ReadWrite(bits: 0..<1, as: EVENTS_ENDRX_FIELDValues.self)
        var events_endrx_field: EVENTS_ENDRX_FIELD
    }

    /// Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer
    @Register(bitWidth: 32)
    struct EVENTS_ENDTX {
        /// Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer
        @ReadWrite(bits: 0..<1, as: EVENTS_ENDTX_FIELDValues.self)
        var events_endtx_field: EVENTS_ENDTX_FIELD
    }

    /// Auto collision resolution process has started
    @Register(bitWidth: 32)
    struct EVENTS_AUTOCOLRESSTARTED {
        /// Auto collision resolution process has started
        @ReadWrite(bits: 0..<1, as: EVENTS_AUTOCOLRESSTARTED_FIELDValues.self)
        var events_autocolresstarted_field: EVENTS_AUTOCOLRESSTARTED_FIELD
    }

    /// NFC auto collision resolution error reported.
    @Register(bitWidth: 32)
    struct EVENTS_COLLISION {
        /// NFC auto collision resolution error reported.
        @ReadWrite(bits: 0..<1, as: EVENTS_COLLISION_FIELDValues.self)
        var events_collision_field: EVENTS_COLLISION_FIELD
    }

    /// NFC auto collision resolution successfully completed
    @Register(bitWidth: 32)
    struct EVENTS_SELECTED {
        /// NFC auto collision resolution successfully completed
        @ReadWrite(bits: 0..<1, as: EVENTS_SELECTED_FIELDValues.self)
        var events_selected_field: EVENTS_SELECTED_FIELD
    }

    /// EasyDMA is ready to receive or send frames.
    @Register(bitWidth: 32)
    struct EVENTS_STARTED {
        /// EasyDMA is ready to receive or send frames.
        @ReadWrite(bits: 0..<1, as: EVENTS_STARTED_FIELDValues.self)
        var events_started_field: EVENTS_STARTED_FIELD
    }

    /// Shortcuts between local events and tasks
    @Register(bitWidth: 32)
    struct SHORTS {
        /// Shortcut between event FIELDDETECTED and task ACTIVATE
        @ReadWrite(bits: 0..<1, as: FIELDDETECTED_ACTIVATEValues.self)
        var fielddetected_activate: FIELDDETECTED_ACTIVATE

        /// Shortcut between event FIELDLOST and task SENSE
        @ReadWrite(bits: 1..<2, as: FIELDLOST_SENSEValues.self)
        var fieldlost_sense: FIELDLOST_SENSE

        /// Shortcut between event TXFRAMEEND and task ENABLERXDATA
        @ReadWrite(bits: 5..<6, as: TXFRAMEEND_ENABLERXDATAValues.self)
        var txframeend_enablerxdata: TXFRAMEEND_ENABLERXDATA
    }

    /// Enable or disable interrupt
    @Register(bitWidth: 32)
    struct INTEN {
        /// Enable or disable interrupt for event READY
        @ReadWrite(bits: 0..<1, as: READYValues.self)
        var ready: READY

        /// Enable or disable interrupt for event FIELDDETECTED
        @ReadWrite(bits: 1..<2, as: FIELDDETECTEDValues.self)
        var fielddetected: FIELDDETECTED

        /// Enable or disable interrupt for event FIELDLOST
        @ReadWrite(bits: 2..<3, as: FIELDLOSTValues.self)
        var fieldlost: FIELDLOST

        /// Enable or disable interrupt for event TXFRAMESTART
        @ReadWrite(bits: 3..<4, as: TXFRAMESTARTValues.self)
        var txframestart: TXFRAMESTART

        /// Enable or disable interrupt for event TXFRAMEEND
        @ReadWrite(bits: 4..<5, as: TXFRAMEENDValues.self)
        var txframeend: TXFRAMEEND

        /// Enable or disable interrupt for event RXFRAMESTART
        @ReadWrite(bits: 5..<6, as: RXFRAMESTARTValues.self)
        var rxframestart: RXFRAMESTART

        /// Enable or disable interrupt for event RXFRAMEEND
        @ReadWrite(bits: 6..<7, as: RXFRAMEENDValues.self)
        var rxframeend: RXFRAMEEND

        /// Enable or disable interrupt for event ERROR
        @ReadWrite(bits: 7..<8, as: ERRORValues.self)
        var error: ERROR

        /// Enable or disable interrupt for event RXERROR
        @ReadWrite(bits: 10..<11, as: RXERRORValues.self)
        var rxerror: RXERROR

        /// Enable or disable interrupt for event ENDRX
        @ReadWrite(bits: 11..<12, as: ENDRXValues.self)
        var endrx: ENDRX

        /// Enable or disable interrupt for event ENDTX
        @ReadWrite(bits: 12..<13, as: ENDTXValues.self)
        var endtx: ENDTX

        /// Enable or disable interrupt for event AUTOCOLRESSTARTED
        @ReadWrite(bits: 14..<15, as: AUTOCOLRESSTARTEDValues.self)
        var autocolresstarted: AUTOCOLRESSTARTED

        /// Enable or disable interrupt for event COLLISION
        @ReadWrite(bits: 18..<19, as: COLLISIONValues.self)
        var collision: COLLISION

        /// Enable or disable interrupt for event SELECTED
        @ReadWrite(bits: 19..<20, as: SELECTEDValues.self)
        var selected: SELECTED

        /// Enable or disable interrupt for event STARTED
        @ReadWrite(bits: 20..<21, as: STARTEDValues.self)
        var started: STARTED
    }

    /// Enable interrupt
    @Register(bitWidth: 32)
    struct INTENSET {
        /// Write '1' to enable interrupt for event READY
        @ReadWrite(bits: 0..<1)
        var ready: READY

        /// Write '1' to enable interrupt for event FIELDDETECTED
        @ReadWrite(bits: 1..<2)
        var fielddetected: FIELDDETECTED

        /// Write '1' to enable interrupt for event FIELDLOST
        @ReadWrite(bits: 2..<3)
        var fieldlost: FIELDLOST

        /// Write '1' to enable interrupt for event TXFRAMESTART
        @ReadWrite(bits: 3..<4)
        var txframestart: TXFRAMESTART

        /// Write '1' to enable interrupt for event TXFRAMEEND
        @ReadWrite(bits: 4..<5)
        var txframeend: TXFRAMEEND

        /// Write '1' to enable interrupt for event RXFRAMESTART
        @ReadWrite(bits: 5..<6)
        var rxframestart: RXFRAMESTART

        /// Write '1' to enable interrupt for event RXFRAMEEND
        @ReadWrite(bits: 6..<7)
        var rxframeend: RXFRAMEEND

        /// Write '1' to enable interrupt for event ERROR
        @ReadWrite(bits: 7..<8)
        var error: ERROR

        /// Write '1' to enable interrupt for event RXERROR
        @ReadWrite(bits: 10..<11)
        var rxerror: RXERROR

        /// Write '1' to enable interrupt for event ENDRX
        @ReadWrite(bits: 11..<12)
        var endrx: ENDRX

        /// Write '1' to enable interrupt for event ENDTX
        @ReadWrite(bits: 12..<13)
        var endtx: ENDTX

        /// Write '1' to enable interrupt for event AUTOCOLRESSTARTED
        @ReadWrite(bits: 14..<15)
        var autocolresstarted: AUTOCOLRESSTARTED

        /// Write '1' to enable interrupt for event COLLISION
        @ReadWrite(bits: 18..<19)
        var collision: COLLISION

        /// Write '1' to enable interrupt for event SELECTED
        @ReadWrite(bits: 19..<20)
        var selected: SELECTED

        /// Write '1' to enable interrupt for event STARTED
        @ReadWrite(bits: 20..<21)
        var started: STARTED
    }

    /// Disable interrupt
    @Register(bitWidth: 32)
    struct INTENCLR {
        /// Write '1' to disable interrupt for event READY
        @ReadWrite(bits: 0..<1)
        var ready: READY

        /// Write '1' to disable interrupt for event FIELDDETECTED
        @ReadWrite(bits: 1..<2)
        var fielddetected: FIELDDETECTED

        /// Write '1' to disable interrupt for event FIELDLOST
        @ReadWrite(bits: 2..<3)
        var fieldlost: FIELDLOST

        /// Write '1' to disable interrupt for event TXFRAMESTART
        @ReadWrite(bits: 3..<4)
        var txframestart: TXFRAMESTART

        /// Write '1' to disable interrupt for event TXFRAMEEND
        @ReadWrite(bits: 4..<5)
        var txframeend: TXFRAMEEND

        /// Write '1' to disable interrupt for event RXFRAMESTART
        @ReadWrite(bits: 5..<6)
        var rxframestart: RXFRAMESTART

        /// Write '1' to disable interrupt for event RXFRAMEEND
        @ReadWrite(bits: 6..<7)
        var rxframeend: RXFRAMEEND

        /// Write '1' to disable interrupt for event ERROR
        @ReadWrite(bits: 7..<8)
        var error: ERROR

        /// Write '1' to disable interrupt for event RXERROR
        @ReadWrite(bits: 10..<11)
        var rxerror: RXERROR

        /// Write '1' to disable interrupt for event ENDRX
        @ReadWrite(bits: 11..<12)
        var endrx: ENDRX

        /// Write '1' to disable interrupt for event ENDTX
        @ReadWrite(bits: 12..<13)
        var endtx: ENDTX

        /// Write '1' to disable interrupt for event AUTOCOLRESSTARTED
        @ReadWrite(bits: 14..<15)
        var autocolresstarted: AUTOCOLRESSTARTED

        /// Write '1' to disable interrupt for event COLLISION
        @ReadWrite(bits: 18..<19)
        var collision: COLLISION

        /// Write '1' to disable interrupt for event SELECTED
        @ReadWrite(bits: 19..<20)
        var selected: SELECTED

        /// Write '1' to disable interrupt for event STARTED
        @ReadWrite(bits: 20..<21)
        var started: STARTED
    }

    /// NFC Error Status register
    @Register(bitWidth: 32)
    struct ERRORSTATUS {
        /// No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX
        @ReadWrite(bits: 0..<1)
        var framedelaytimeout: FRAMEDELAYTIMEOUT
    }

    /// NfcTag state register
    @Register(bitWidth: 32)
    struct NFCTAGSTATE {
        /// NfcTag state
        @ReadOnly(bits: 0..<3, as: NFCTAGSTATE_FIELDValues.self)
        var nfctagstate_field: NFCTAGSTATE_FIELD
    }

    /// Sleep state during automatic collision resolution
    @Register(bitWidth: 32)
    struct SLEEPSTATE {
        /// GOSLEEP task.
        @ReadOnly(bits: 0..<1, as: SLEEPSTATE_FIELDValues.self)
        var sleepstate_field: SLEEPSTATE_FIELD
    }

    /// Indicates the presence or not of a valid field
    @Register(bitWidth: 32)
    struct FIELDPRESENT {
        /// Indicates if a valid field is present. Available only in the activated state.
        @ReadOnly(bits: 0..<1, as: FIELDPRESENT_FIELDValues.self)
        var fieldpresent_field: FIELDPRESENT_FIELD

        /// Indicates if the low level has locked to the field
        @ReadOnly(bits: 1..<2, as: LOCKDETECTValues.self)
        var lockdetect: LOCKDETECT
    }

    /// Minimum frame delay
    @Register(bitWidth: 32)
    struct FRAMEDELAYMIN {
        /// Minimum frame delay in number of 13.56 MHz clocks
        @ReadWrite(bits: 0..<16)
        var framedelaymin_field: FRAMEDELAYMIN_FIELD
    }

    /// Maximum frame delay
    @Register(bitWidth: 32)
    struct FRAMEDELAYMAX {
        /// Maximum frame delay in number of 13.56 MHz clocks
        @ReadWrite(bits: 0..<20)
        var framedelaymax_field: FRAMEDELAYMAX_FIELD
    }

    /// Configuration register for the Frame Delay Timer
    @Register(bitWidth: 32)
    struct FRAMEDELAYMODE {
        /// Configuration register for the Frame Delay Timer
        @ReadWrite(bits: 0..<2, as: FRAMEDELAYMODE_FIELDValues.self)
        var framedelaymode_field: FRAMEDELAYMODE_FIELD
    }

    /// Packet pointer for TXD and RXD data storage in Data RAM
    @Register(bitWidth: 32)
    struct PACKETPTR {
        /// Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte-aligned RAM address.
        @ReadWrite(bits: 0..<32)
        var ptr: PTR
    }

    /// Size of the RAM buffer allocated to TXD and RXD data storage each
    @Register(bitWidth: 32)
    struct MAXLEN {
        /// Size of the RAM buffer allocated to TXD and RXD data storage each
        @ReadWrite(bits: 0..<9)
        var maxlen_field: MAXLEN_FIELD
    }

    /// Enables the modulation output to a GPIO pin which can be connected to a second external antenna.
    @Register(bitWidth: 32)
    struct MODULATIONCTRL {
        /// Configuration of modulation control.
        @ReadWrite(bits: 0..<2, as: MODULATIONCTRL_FIELDValues.self)
        var modulationctrl_field: MODULATIONCTRL_FIELD
    }

    /// Pin select for Modulation control.
    @Register(bitWidth: 32)
    struct MODULATIONPSEL {
        /// Pin number
        @ReadWrite(bits: 0..<5)
        var pin: PIN

        /// Port number
        @ReadWrite(bits: 5..<6)
        var port: PORT

        /// Connection
        @ReadWrite(bits: 31..<32, as: CONNECTValues.self)
        var connect: CONNECT
    }

    /// Last NFCID1 part (4, 7 or 10 bytes ID)
    @Register(bitWidth: 32)
    struct NFCID1_LAST {
        /// NFCID1 byte Z (very last byte sent)
        @ReadWrite(bits: 0..<8)
        var nfcid1_z: NFCID1_Z

        /// NFCID1 byte Y
        @ReadWrite(bits: 8..<16)
        var nfcid1_y: NFCID1_Y

        /// NFCID1 byte X
        @ReadWrite(bits: 16..<24)
        var nfcid1_x: NFCID1_X

        /// NFCID1 byte W
        @ReadWrite(bits: 24..<32)
        var nfcid1_w: NFCID1_W
    }

    /// Second last NFCID1 part (7 or 10 bytes ID)
    @Register(bitWidth: 32)
    struct NFCID1_2ND_LAST {
        /// NFCID1 byte V
        @ReadWrite(bits: 0..<8)
        var nfcid1_v: NFCID1_V

        /// NFCID1 byte U
        @ReadWrite(bits: 8..<16)
        var nfcid1_u: NFCID1_U

        /// NFCID1 byte T
        @ReadWrite(bits: 16..<24)
        var nfcid1_t: NFCID1_T
    }

    /// Third last NFCID1 part (10 bytes ID)
    @Register(bitWidth: 32)
    struct NFCID1_3RD_LAST {
        /// NFCID1 byte S
        @ReadWrite(bits: 0..<8)
        var nfcid1_s: NFCID1_S

        /// NFCID1 byte R
        @ReadWrite(bits: 8..<16)
        var nfcid1_r: NFCID1_R

        /// NFCID1 byte Q
        @ReadWrite(bits: 16..<24)
        var nfcid1_q: NFCID1_Q
    }

    /// Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated.
    @Register(bitWidth: 32)
    struct AUTOCOLRESCONFIG {
        /// Enables/disables auto collision resolution
        @ReadWrite(bits: 0..<1, as: MODEValues.self)
        var mode: MODE
    }

    /// NFC-A SENS_RES auto-response settings
    @Register(bitWidth: 32)
    struct SENSRES {
        /// Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        @ReadWrite(bits: 0..<5, as: BITFRAMESDDValues.self)
        var bitframesdd: BITFRAMESDD

        /// Reserved for future use. Shall be 0.
        @ReadWrite(bits: 5..<6)
        var rfu5: RFU5

        /// NFCID1 size. This value is used by the auto collision resolution engine.
        @ReadWrite(bits: 6..<8, as: NFCIDSIZEValues.self)
        var nfcidsize: NFCIDSIZE

        /// Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        @ReadWrite(bits: 8..<12)
        var platfconfig: PLATFCONFIG

        /// Reserved for future use. Shall be 0.
        @ReadWrite(bits: 12..<16)
        var rfu74: RFU74
    }

    /// NFC-A SEL_RES auto-response settings
    @Register(bitWidth: 32)
    struct SELRES {
        /// Reserved for future use. Shall be 0.
        @ReadWrite(bits: 0..<2)
        var rfu10: RFU10

        /// Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)
        @ReadWrite(bits: 2..<3)
        var cascade: CASCADE

        /// Reserved for future use. Shall be 0.
        @ReadWrite(bits: 3..<5)
        var rfu43: RFU43

        /// Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        @ReadWrite(bits: 5..<7)
        var `protocol`: PROTOCOL

        /// Reserved for future use. Shall be 0.
        @ReadWrite(bits: 7..<8)
        var rfu7: RFU7
    }

    /// Unspecified
    @RegisterBlock
    struct FRAMESTATUS {
        /// Result of last incoming frame
        @RegisterBlock(offset: 0x0)
        var rx: Register<RX>
    }

    /// Unspecified
    @RegisterBlock
    struct TXD {
        /// Configuration of outgoing frames
        @RegisterBlock(offset: 0x0)
        var frameconfig: Register<FRAMECONFIG>

        /// Size of outgoing frame
        @RegisterBlock(offset: 0x4)
        var amount: Register<AMOUNT>
    }

    /// Unspecified
    @RegisterBlock
    struct RXD {
        /// Configuration of incoming frames
        @RegisterBlock(offset: 0x0)
        var frameconfig: Register<FRAMECONFIG>

        /// Size of last incoming frame
        @RegisterBlock(offset: 0x4)
        var amount: Register<AMOUNT>
    }
}

extension NFCT.FRAMESTATUS {
    /// Result of last incoming frame
    @Register(bitWidth: 32)
    struct RX {
        /// No valid end of frame (EoF) detected
        @ReadWrite(bits: 0..<1, as: CRCERRORValues.self)
        var crcerror: CRCERROR

        /// Parity status of received frame
        @ReadWrite(bits: 2..<3, as: PARITYSTATUSValues.self)
        var paritystatus: PARITYSTATUS

        /// Overrun detected
        @ReadWrite(bits: 3..<4, as: OVERRUNValues.self)
        var overrun: OVERRUN
    }
}

extension NFCT.TXD {
    /// Configuration of outgoing frames
    @Register(bitWidth: 32)
    struct FRAMECONFIG {
        /// Indicates if parity is added to the frame
        @ReadWrite(bits: 0..<1, as: PARITYValues.self)
        var parity: PARITY

        /// Discarding unused bits at start or end of a frame
        @ReadWrite(bits: 1..<2, as: DISCARDMODEValues.self)
        var discardmode: DISCARDMODE

        /// Adding SoF or not in TX frames
        @ReadWrite(bits: 2..<3, as: SOFValues.self)
        var sof: SOF

        /// CRC mode for outgoing frames
        @ReadWrite(bits: 4..<5, as: CRCMODETXValues.self)
        var crcmodetx: CRCMODETX
    }

    /// Size of outgoing frame
    @Register(bitWidth: 32)
    struct AMOUNT {
        /// Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit).
        @ReadWrite(bits: 0..<3)
        var txdatabits: TXDATABITS

        /// Number of complete bytes that shall be included in the frame, excluding CRC, parity and framing
        @ReadWrite(bits: 3..<12)
        var txdatabytes: TXDATABYTES
    }
}

extension NFCT.RXD {
    /// Configuration of incoming frames
    @Register(bitWidth: 32)
    struct FRAMECONFIG {
        /// Indicates if parity expected in RX frame
        @ReadWrite(bits: 0..<1, as: PARITYValues.self)
        var parity: PARITY

        /// SoF expected or not in RX frames
        @ReadWrite(bits: 2..<3, as: SOFValues.self)
        var sof: SOF

        /// CRC mode for incoming frames
        @ReadWrite(bits: 4..<5, as: CRCMODERXValues.self)
        var crcmoderx: CRCMODERX
    }

    /// Size of last incoming frame
    @Register(bitWidth: 32)
    struct AMOUNT {
        /// Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing).
        @ReadOnly(bits: 0..<3)
        var rxdatabits: RXDATABITS

        /// Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)
        @ReadOnly(bits: 3..<12)
        var rxdatabytes: RXDATABYTES
    }
}

extension NFCT.TASKS_ACTIVATE {
    struct TASKS_ACTIVATE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TASKS_DISABLE {
    struct TASKS_DISABLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TASKS_SENSE {
    struct TASKS_SENSE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TASKS_STARTTX {
    struct TASKS_STARTTX_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TASKS_ENABLERXDATA {
    struct TASKS_ENABLERXDATA_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TASKS_GOIDLE {
    struct TASKS_GOIDLE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TASKS_GOSLEEP {
    struct TASKS_GOSLEEP_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Trigger task
        static let Trigger = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_READY {
    struct EVENTS_READY_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_FIELDDETECTED {
    struct EVENTS_FIELDDETECTED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_FIELDLOST {
    struct EVENTS_FIELDLOST_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_TXFRAMESTART {
    struct EVENTS_TXFRAMESTART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_TXFRAMEEND {
    struct EVENTS_TXFRAMEEND_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_RXFRAMESTART {
    struct EVENTS_RXFRAMESTART_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_RXFRAMEEND {
    struct EVENTS_RXFRAMEEND_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_ERROR {
    struct EVENTS_ERROR_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_RXERROR {
    struct EVENTS_RXERROR_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_ENDRX {
    struct EVENTS_ENDRX_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_ENDTX {
    struct EVENTS_ENDTX_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_AUTOCOLRESSTARTED {
    struct EVENTS_AUTOCOLRESSTARTED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_COLLISION {
    struct EVENTS_COLLISION_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_SELECTED {
    struct EVENTS_SELECTED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.EVENTS_STARTED {
    struct EVENTS_STARTED_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Event not generated
        static let NotGenerated = Self(rawValue: 0x0)

        /// Event generated
        static let Generated = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.SHORTS {
    struct FIELDDETECTED_ACTIVATEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.SHORTS {
    struct FIELDLOST_SENSEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.SHORTS {
    struct TXFRAMEEND_ENABLERXDATAValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable shortcut
        static let Disabled = Self(rawValue: 0x0)

        /// Enable shortcut
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct READYValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct FIELDDETECTEDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct FIELDLOSTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct TXFRAMESTARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct TXFRAMEENDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct RXFRAMESTARTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct RXFRAMEENDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct ERRORValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct RXERRORValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct ENDRXValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct ENDTXValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct AUTOCOLRESSTARTEDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct COLLISIONValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct SELECTEDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.INTEN {
    struct STARTEDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disable
        static let Disabled = Self(rawValue: 0x0)

        /// Enable
        static let Enabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.NFCTAGSTATE {
    struct NFCTAGSTATE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 3

        /// Disabled or sense
        static let Disabled = Self(rawValue: 0x0)

        /// RampUp
        static let RampUp = Self(rawValue: 0x2)

        /// Idle
        static let Idle = Self(rawValue: 0x3)

        /// Receive
        static let Receive = Self(rawValue: 0x4)

        /// FrameDelay
        static let FrameDelay = Self(rawValue: 0x5)

        /// Transmit
        static let Transmit = Self(rawValue: 0x6)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.SLEEPSTATE {
    struct SLEEPSTATE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// State is IDLE.
        static let Idle = Self(rawValue: 0x0)

        /// State is SLEEP_A.
        static let SleepA = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.FIELDPRESENT {
    struct FIELDPRESENT_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// No valid field detected
        static let NoField = Self(rawValue: 0x0)

        /// Valid field detected
        static let FieldPresent = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.FIELDPRESENT {
    struct LOCKDETECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Not locked to field
        static let NotLocked = Self(rawValue: 0x0)

        /// Locked to field
        static let Locked = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.FRAMEDELAYMODE {
    struct FRAMEDELAYMODE_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout.
        static let FreeRun = Self(rawValue: 0x0)

        /// Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX
        static let Window = Self(rawValue: 0x1)

        /// Frame is transmitted exactly at FRAMEDELAYMAX
        static let ExactVal = Self(rawValue: 0x2)

        /// Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX
        static let WindowGrid = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.MODULATIONCTRL {
    struct MODULATIONCTRL_FIELDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// Invalid, defaults to same behaviour as for Internal
        static let Invalid = Self(rawValue: 0x0)

        /// Use internal modulator only
        static let Internal = Self(rawValue: 0x1)

        /// Output digital modulation signal to a GPIO pin.
        static let ModToGpio = Self(rawValue: 0x2)

        /// Use internal modulator and output digital modulation signal to a GPIO pin.
        static let InternalAndModToGpio = Self(rawValue: 0x3)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.MODULATIONPSEL {
    struct CONNECTValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Disconnect
        static let Disconnected = Self(rawValue: 0x1)

        /// Connect
        static let Connected = Self(rawValue: 0x0)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.AUTOCOLRESCONFIG {
    struct MODEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Auto collision resolution enabled
        static let Enabled = Self(rawValue: 0x0)

        /// Auto collision resolution disabled
        static let Disabled = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.SENSRES {
    struct BITFRAMESDDValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 5

        /// SDD pattern 00000
        static let SDD00000 = Self(rawValue: 0x0)

        /// SDD pattern 00001
        static let SDD00001 = Self(rawValue: 0x1)

        /// SDD pattern 00010
        static let SDD00010 = Self(rawValue: 0x2)

        /// SDD pattern 00100
        static let SDD00100 = Self(rawValue: 0x4)

        /// SDD pattern 01000
        static let SDD01000 = Self(rawValue: 0x8)

        /// SDD pattern 10000
        static let SDD10000 = Self(rawValue: 0x10)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.SENSRES {
    struct NFCIDSIZEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 2

        /// NFCID1 size: single (4 bytes)
        static let NFCID1Single = Self(rawValue: 0x0)

        /// NFCID1 size: double (7 bytes)
        static let NFCID1Double = Self(rawValue: 0x1)

        /// NFCID1 size: triple (10 bytes)
        static let NFCID1Triple = Self(rawValue: 0x2)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.FRAMESTATUS.RX {
    struct CRCERRORValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Valid CRC detected
        static let CRCCorrect = Self(rawValue: 0x0)

        /// CRC received does not match local check
        static let CRCError = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.FRAMESTATUS.RX {
    struct PARITYSTATUSValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Frame received with parity OK
        static let ParityOK = Self(rawValue: 0x0)

        /// Frame received with parity error
        static let ParityError = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.FRAMESTATUS.RX {
    struct OVERRUNValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// No overrun detected
        static let NoOverrun = Self(rawValue: 0x0)

        /// Overrun error
        static let Overrun = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TXD.FRAMECONFIG {
    struct PARITYValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Parity is not added to TX frames
        static let NoParity = Self(rawValue: 0x0)

        /// Parity is added to TX frames
        static let Parity = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TXD.FRAMECONFIG {
    struct DISCARDMODEValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Unused bits are discarded at end of frame (EoF)
        static let DiscardEnd = Self(rawValue: 0x0)

        /// Unused bits are discarded at start of frame (SoF)
        static let DiscardStart = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TXD.FRAMECONFIG {
    struct SOFValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// SoF symbol not added
        static let NoSoF = Self(rawValue: 0x0)

        /// SoF symbol added
        static let SoF = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.TXD.FRAMECONFIG {
    struct CRCMODETXValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// CRC is not added to the frame
        static let NoCRCTX = Self(rawValue: 0x0)

        /// 16 bit CRC added to the frame based on all the data read from RAM that is used in the frame
        static let CRC16TX = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.RXD.FRAMECONFIG {
    struct PARITYValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// Parity is not expected in RX frames
        static let NoParity = Self(rawValue: 0x0)

        /// Parity is expected in RX frames
        static let Parity = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.RXD.FRAMECONFIG {
    struct SOFValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// SoF symbol is not expected in RX frames
        static let NoSoF = Self(rawValue: 0x0)

        /// SoF symbol is expected in RX frames
        static let SoF = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}

extension NFCT.RXD.FRAMECONFIG {
    struct CRCMODERXValues: BitFieldProjectable, RawRepresentable {
        static let bitWidth = 1

        /// CRC is not expected in RX frames
        static let NoCRCRX = Self(rawValue: 0x0)

        /// Last 16 bits in RX frame is CRC, CRC is checked and CRCSTATUS updated
        static let CRC16RX = Self(rawValue: 0x1)

        var rawValue: UInt8

        @inlinable @inline(__always)
        init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
